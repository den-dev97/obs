### **Что такое Vue.js и почему бы его использовать?** 
Vue.js — это прогрессивный JavaScript-фреймворк, используемый для создания пользовательских интерфейсов. Он легко интегрируется с существующими проектами благодаря своей прогрессивности и может быть расширен для создания сложных одностраничных приложений. Vue предлагает реактивные компоненты и удобный интерфейс API, что делает его простым и мощным инструментом для разработки веб-приложений.
### **Что такое директивы во Vue.js?** 
Директивы в Vue.js — это специальные атрибуты, которые предоставляют способы применения реактивного поведения к DOM. Например, директива `v-bind` используется для реактивного обновления HTML-атрибутов, а директива `v-on` служит для прослушивания DOM-событий.
### **Что такое компоненты во Vue.js?** 
Компоненты в Vue — это переиспользуемые Vue экземпляры с именем. Компоненты могут быть использованы для создания пользовательских элементов в Vue, которые могут быть повторно использованы по всему приложению.
### **Что такое однофайловые компоненты Vue (.vue)?** 
Однофайловые компоненты (SFCs) — это файлы с расширением `.vue`, которые содержат три секции: `<template>`, `<script>` и `<style>`. Эти секции соответствуют структуре, поведению и стилю компонента соответственно. Однофайловые компоненты обеспечивают удобный способ организации и структурирования кода.
### **Как происходит условный рендеринг во Vue.js?** 
Условный рендеринг во Vue.js обычно выполняется с помощью директив `v-if`, `v-else` и `v-else-if`. Эти директивы используются для отображения или скрытия элемента в зависимости от значения логического выражения.
### **Что такое миксины во Vue.js?** 
Миксины в Vue.js — это способ объединения функциональности между компонентами. Миксин объект может содержать любые опции компонента. Когда компонент использует миксин, все опции миксина "смешиваются" с опциями компонента.
***
### **Как работает система реактивности во Vue.js?** 

Система реактивности в Vue.js отвечает за отслеживание изменений в данных и автоматическое обновление DOM в соответствии с этими изменениями.
В Vue 2.x система реактивности основывается на ES5 функциях `Object.defineProperty()`. Vue обходит каждое свойство в данных компонента и преобразует их в геттеры и сеттеры с использованием `Object.defineProperty()`.

- Геттеры используются для сбора зависимостей (какие компоненты зависят от каких свойств).
- Сеттеры оповещают о том, что свойство изменилось, чтобы Vue мог обновить все зависимые компоненты.

Метод `Object.defineProperty()` является частью JavaScript API для работы с объектами. Он позволяет определить новое или изменить существующее свойство прямо на объекте и предоставляет большую контроль над его поведением, чем обычное присваивание значения свойству.
`Object.defineProperty(obj, prop, descriptor)`
- `obj` - объект, на котором определяется свойство.
- `prop` - строка или символ, имя свойства, которое нужно определить или изменить.
- `descriptor` - объект, описывающий свойство. Может включать следующие поля:
    - `value`: значение свойства. По умолчанию `undefined`.
    - `writable`: если `true`, свойство можно изменить. По умолчанию `false`.
    - `configurable`: если `true`, свойство можно удалить, а эти атрибуты (кроме `value` и `writable`) можно изменить позже. По умолчанию `false`.
    - `enumerable`: если `true`, свойство появляется при перечислении свойств объекта в цикле `for...in` или с использованием `Object.keys()`. По умолчанию `false`.
    - `get`: функция, которая будет вызвана при попытке чтения значения свойства. Если не указана, возвращает `undefined`.
    - `set`: функция, которая будет вызвана при попытке изменить значение свойства. Получает новое значение в качестве аргумента.
Пример использования `Object.defineProperty()`:
```
let obj = {};

Object.defineProperty(obj, 'example', {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: true
});

console.log(obj.example); // 42
obj.example = 99;
console.log(obj.example); // 42, потому что свойство не writable
```

1. Vue не может отслеживать добавление новых свойств или удаление существующих свойств объекта после его создания, потому что геттеры и сеттеры устанавливаются на уже существующих свойствах при инициализации. Когда новое свойство добавляется в объект после инициализации, Vue.js не знает о его добавлении и, следовательно, не создает для него реактивные геттеры и сеттеры.
2. Аналогично, он не может отслеживать удаление свойств, потому что свойства, которые были удалены, уже не имеют геттеров и сеттеров, и Vue.js не может определить, были ли они удалены.

Чтобы обойти эти ограничения, Vue предлагает две специальные метода: `Vue.set()` (или эквивалентную ему `this.$set()`) и `Vue.delete()` (или `this.$delete()`).
```
this.$set(this.obj, 'newProp', 'newValue');

this.$delete(this.obj, 'propToDelete');
```
Если вы работаете с массивами и хотите изменить значение по индексу, вы можете использовать `this.$set()`:
`this.$set(this.array, index, newValue);`

Тем не менее, большинство манипуляций с массивами, таких как `push`, `pop`, `shift`, `unshift`, `splice`, `sort`, `reverse` и так далее, уже обрабатываются Vue 2 реактивно.

В Vue 3.x система реактивности была полностью переписана с использованием нового ES6 Proxy API, который позволяет более эффективно и полностью отслеживать изменения.

- С помощью `Proxy`, Vue теперь может отслеживать изменения в массивах по индексам и отслеживать добавление или удаление свойств из объектов.
- `Proxy` также упрощает внутреннюю реализацию системы реактивности, делая ее более эффективной и мощной.

`Proxy` в JavaScript представляет собой объект, который оборачивает другой объект или функцию и позволяет вам перехватывать и переопределять операции на целевом объекте или функции.

Простейший пример создания прокси выглядит так:
```
let targetObject = {};

let proxy = new Proxy(targetObject, {});

// Сейчас мы можем взаимодействовать с объектом через прокси
proxy.property = "Hello, World!";

console.log(targetObject.property);  // Вывод: "Hello, World!"
```
В этом примере мы создали `Proxy`, обернув `targetObject`. Второй аргумент для конструктора `Proxy` - это обработчик (handler), который содержит ловушки (traps). Ловушки позволяют перехватывать операции на целевом объекте. Например, мы можем перехватить обращение к свойству:
```
let targetObject = {
  property: "Hello, World!"
};

let handler = {
  get(target, property) {
    console.log(`Getting property ${property}`);
    return target[property];
  }
};

let proxy = new Proxy(targetObject, handler);

console.log(proxy.property);
// Вывод:
// Getting property property
// Hello, World!
```

Несмотря на эти различия, базовый принцип работы реактивности остается прежним: Vue отслеживает изменения в данных и обновляет DOM, когда данные изменяются.
***
## Что такое get() и set() 
`get()` и `set()` в JavaScript часто называют геттерами и сеттерами. Они являются специальными типами функций, которые позволяют определять, что происходит при получении (get) или установке (set) значения свойства объекта.

**Геттеры (`get()`)** позволяют вам определить функцию, которая будет вызываться, когда к свойству происходит обращение. Они могут быть полезны, когда значение свойства зависит от состояния других свойств.

**Сеттеры (`set()`)** позволяют вам определить функцию, которая будет вызываться, когда свойству присваивается новое значение. Сеттеры могут быть полезны, когда вам нужно выполнять валидацию или преобразование данных перед их сохранением.

Пример использования геттеров и сеттеров:
```
let obj = {
  _age: 25, // префикс "_" обычно используется для отметки внутренних переменных

  get age() {
    return this._age;
  },

  set age(value) {
    if (value < 0 || value > 120) {
      console.log("Недопустимый возраст");
    } else {
      this._age = value;
    }
  }
};

console.log(obj.age); // 25
obj.age = 130; // "Недопустимый возраст"
console.log(obj.age); // 25 (значение не изменилось)
obj.age = 30;
console.log(obj.age); // 30
```
В контексте `Proxy`, `get()` и `set()` также являются ловушками, которые позволяют перехватить и переопределить операции чтения и записи свойств:
```
let target = {};
let handler = {
  get(target, prop) {
    console.log(`Reading property ${prop}`);
    return target[prop];
  },

  set(target, prop, value) {
    console.log(`Writing property ${prop} with value ${value}`);
    target[prop] = value;
    return true; // обозначает успешное выполнение операции установки
  }
};
let proxy = new Proxy(target, handler);

proxy.foo; // Reading property foo
proxy.foo = "bar"; // Writing property foo with value bar
```

## Какие проблемы есть во Vue 3
Во Vue.js 3 было внедрено множество значительных улучшений по сравнению с Vue.js 2, включая улучшенную производительность, новый API Composition, улучшенную систему реактивности с использованием JavaScript Proxy и другое. Но, как и любой другой инструмент или библиотека, Vue.js 3 не идеален и имеет свои недостатки и проблемы.

1. **Совместимость с библиотеками Vue 2**: Несмотря на то что Vue 3 предлагает ряд улучшений, некоторые сторонние библиотеки или плагины, созданные для Vue 2, могут не быть совместимы с Vue 3 без дополнительных усилий.
2. **Кривая обучения**: Новый Composition API во Vue 3 предлагает больше гибкости разработчикам, но он также может сделать код сложнее для понимания для тех, кто только начинает работать с Vue. Это делает кривую обучения Vue 3 круче по сравнению с Vue 2.
3. **Прозрачность Proxy**: Vue 3 использует Proxy API для реализации реактивности, что устраняет некоторые ограничения Vue 2. Однако, из-за прозрачности Proxy, иногда может быть сложно понять, работаете ли вы с реактивным объектом или с обычным объектом. Это может вызвать проблемы при отладке или внедрении функций, основанных на низкоуровневой манипуляции объектами.
4. **Поддержка браузеров**: JavaScript Proxy, используемый Vue 3 для реактивности, не поддерживается в Internet Explorer и не может быть полифиллен, что делает Vue 3 непригодным для проектов, которые требуют поддержки IE.

### **Что такое Vuex?** 
Vuex — это библиотека для управления состоянием приложения, разработанная специально для Vue.js. Она служит как единый источник истины для всех данных приложения, позволяя компонентам обмениваться состоянием без необходимости передавать свойства вниз по дереву компонентов или использовать события для передачи данных вверх.

Вот основные концепции Vuex:

1. **Состояние (State)**: Это единый источник истины для приложения. Все компоненты получают свои данные из общего состояния.
2. **Мутации (Mutations)**: Это единственный способ изменить состояние. Мутации в Vuex являются синхронными.
3. **Действия (Actions)**: Это подобно мутациям, но они могут быть асинхронными. Действия коммитуют мутации, чтобы изменить состояние.
4. **Геттеры (Getters)**: Геттеры в Vuex позволяют создавать вычисляемые данные на основе состояния, которые будут обновляться, когда изменяются зависимости.
5. **Модули (Modules)**: Vuex позволяет разбивать хранилище на модули, каждый из которых имеет свое собственное состояние, мутации, действия, геттеры, даже вложенные модули.

Vuex полезен для средних и крупных приложений, где управление состоянием может стать сложным и привести к проблемам с производительностью и сложностями отладки. Однако для небольших приложений использование Vuex может быть избыточным.

### **Что такое Vue Router?** 
Vue Router — это официальная библиотека маршрутизации для Vue.js. Она позволяет пользователям переходить между страницами без перезагрузки страницы.

### **Что такое nextTick во Vue.js?** 
`Vue.nextTick()` — это метод, который позволяет задержать выполнение функции до следующего обновления DOM после любых изменений данных. Он полезен, когда вам нужно дождаться, пока Vue обновит DOM в ответ на изменение данных, прежде чем что-то сделать.
***
### Webpack 
— это мощный сборщик модулей и пакетов для JavaScript-приложений. Он собирает все ресурсы вашего приложения (JS-код, HTML, стили, изображения и др.) и преобразует их в статические файлы, которые можно эффективно раздавать в браузере.

Основные особенности Webpack:

1. **Загрузчики (Loaders)**: Webpack может интерпретировать и обрабатывать не только JavaScript, но и другие типы файлов, такие как CSS, HTML, JSON, изображения, шрифты и пр. Это достигается благодаря использованию загрузчиков.
2. **Плагины (Plugins)**: Плагины обеспечивают широкий спектр решений для настройки процесса сборки. Они могут быть использованы для минификации кода, обработки ошибок, автоматического обновления браузера при разработке (hot module replacement) и многого другого.
3. **Модульность (Modularity)**: Webpack умеет работать с модулями. Он поддерживает разные стандарты модульности (CommonJS, AMD, ES6 modules), что позволяет организовать код вашего приложения наиболее удобным образом.
4. **Tree shaking**: Это функция, которая позволяет убрать из конечного бандла неиспользуемый код, что положительно влияет на производительность приложения.
5. **Код-сплиттинг (Code Splitting)**: Это позволяет разбить код приложения на несколько бандлов, которые могут быть загружены по требованию, что также помогает улучшить время загрузки и производительность приложения.

*** 
## Vite и Webpack 
 - это инструменты для сборки и разработки веб-приложений, но они различаются по нескольким ключевым аспектам.
1. **Скорость сборки:** 
Vite использует преобразование кода на основе ES Modules (ESM) и предоставляет значительно более быструю перезагрузку при разработке, поскольку код обрабатывается инкрементально (только измененные файлы). С другой стороны, Webpack пересобирает весь бандл, что может занять больше времени, особенно для больших приложений.
2. **Режим разработки:** 
Webpack использует live-reload для отслеживания изменений в коде и обновления браузера, что может быть медленным для больших приложений. Vite же использует native ES Modules для сервера разработки, что делает горячую замену модулей (HMR) быстрее и эффективнее.
3. **Совместимость:** 
На момент моего знания (до сентября 2021), Webpack имеет более широкую совместимость с различными библиотеками и плагинами, поскольку он существует уже довольно долго. Vite же, будучи более новым инструментом, может не поддерживать некоторые старые плагины или библиотеки.
4. **Конфигурация:** 
Webpack сложнее в настройке и требует более подробной конфигурации. Vite стремится обеспечить минимальную конфигурацию по умолчанию, чтобы упростить процесс для разработчиков.

***
## Pinia и Vuex 
- это оба инструмента для управления состоянием в Vue.js. Они позволяют вам хранить, изменять и отслеживать состояние вашего приложения в централизованном хранилище, упрощая таким образом разделение данных между компонентами.
Vuex - это официальный плагин управления состоянием для Vue.js, который был частью экосистемы Vue с самого начала.
Pinia - это более новый инструмент управления состоянием, созданный одним из основных участников Vue.js, Эдуардом Морьяном. Он был разработан как альтернатива Vuex, и призван облегчить работу с состоянием и сделать код более понятным и меньшим по объему.

Основные отличия Pinia от Vuex:

1. **Синтаксис и структура**: Pinia предлагает более простой и прямой синтаксис по сравнению с Vuex. В Pinia нет разделения на мутации и действия, вы просто определяете функции, которые изменяют состояние вашего хранилища.
2. **Интеграция с TypeScript**: Pinia предлагает более совершенную поддержку TypeScript, что делает его хорошим выбором для проектов, которые используют TypeScript.
3. **Использование хуков хранилища**: Pinia предлагает хуки хранилища, которые можно использовать для выполнения действий при установке и удалении хранилища.
4. **Навигация по истории**: Pinia имеет встроенную поддержку отслеживания изменений состояния через панель инструментов Vue Devtools.
5. **Поддержка SSR**: Pinia также поддерживает серверный рендеринг (SSR) без необходимости в дополнительной настройке.

Важно заметить, что выбор между Vuex и Pinia в значительной степени зависит от ваших личных предпочтений и требований проекта. Несмотря на некоторые улучшения, которые предлагает Pinia, Vuex остается надежным и проверенным инструментом, который активно поддерживается и широко используется в сообществе Vue.js.
### Vuex
```
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment(state) {
      state.count++
    }
  },
  actions: {
    increment(context) {
      context.commit('increment')
    }
  },
  getters: {
    count: state => state.count
  }
})

// Использование в компоненте
export default {
  computed: {
    count() {
      return this.$store.getters.count
    }
  },
  methods: {
    increment() {
      this.$store.dispatch('increment')
    }
  }
}
```
### Pinia
```
import { createPinia } from 'pinia'

export const useStore = createPinia()

export const useCounterStore = () => {
  return {
    count: 0,
    increment() {
      this.count++
    }
  }
}

// Использование в компоненте
import { useCounterStore } from './store'

export default {
  setup() {
    const store = useCounterStore()

    return {
      count: store.count,
      increment: store.increment
    }
  }
}
```
***
## SSR 
или Server-Side Rendering (рендеринг на стороне сервера), это метод рендеринга веб-страниц, при котором исходный HTML веб-страницы генерируется на сервере, а затем отправляется в браузер, где он отображается для пользователя.
Этот подход отличается от Client-Side Rendering (CSR, рендеринг на стороне клиента), где веб-страница первоначально загружается как "пустой" HTML-файл, а затем динамически наполняется контентом с помощью JavaScript на стороне клиента.
SSR особенно полезен для оптимизации производительности и SEO (поисковой оптимизации), так как поисковые системы лучше индексируют страницы, отрендеренные на сервере, а пользователи видят контент быстрее.
***
## Проблемы во Vue 
С версии Vue 2 до Vue 3 было внесено множество изменений, которые сделали фреймворк более мощным и гибким. Однако эти изменения также привнесли некоторые сложности и потенциальные проблемы. Давайте обсудим некоторые из них:

**Vue 2:**

1. **Реактивность**: В Vue 2, система реактивности основана на ES5 Object.defineProperty, что создает ограничения для обнаружения изменений в массивах и добавления новых свойств в объекты после их создания.
2. **Синтаксис шаблонов**: Хотя синтаксис шаблонов Vue 2 достаточно простой для начала работы, он может быть не таким гибким и мощным, как синтаксис JavaScript. Это означает, что некоторые более сложные логические конструкции могут быть сложными для реализации в шаблонах.

**Vue 3:**

1. **Composition API**: Vue 3 ввел Composition API, предлагающий более гибкий и мощный способ создания и организации компонентов. Однако этот новый API имеет более крутую кривую обучения, и многим разработчикам он может показаться сложным и запутанным.
2. **Совместимость**: Несмотря на то, что большинство функциональности Vue 2 все еще поддерживается в Vue 3, есть некоторые нарушения обратной совместимости, которые могут вызвать проблемы при миграции с Vue 2 на Vue 3. Например, некоторые синтаксические изменения в шаблонах и изменения в обработке событий могут требовать изменений в коде.
3. **Изменения в реактивности**: Хотя новая система реактивности на основе Proxy в Vue 3 решает многие проблемы, существующие в Vue 2, она также привносит новые проблемы, связанные с совместимостью с браузерами. Proxy не поддерживается в IE, что означает, что Vue 3 не может быть использован в проектах, которые должны поддерживать IE.
4. **Зависимости от сторонних библиотек**: Поскольку Vue 3 был полностью переписан, многие библиотеки, созданные для Vue 2, несовместимы с Vue 3. Это означает, что разработчикам придется ждать, пока эти библиотеки будут обновлены, или искать альтернативы.

Важно помнить, что и Vue 2, и Vue 3 имеют свои преимущества и недостатки, и выбор между ними должен быть основан на конкретных потребностях проекта.

## Несинхронные мутации 
Несинхронные мутации - это изменения состояния приложения, которые происходят асинхронно, то есть не мгновенно после вызова функции. Они часто встречаются в ситуациях, когда ваши данные зависят от некоторых внешних источников, таких как API, или когда вам нужно выполнить длительную операцию (например, чтение из файла) перед обновлением состояния.

В контексте Vue.js и Vuex, мутации должны быть синхронными. Это связано с тем, что Vuex отслеживает мутации для создания "снимков" состояния, что помогает в отладке приложения с использованием инструмента Vue DevTools.

Если вам нужно выполнить асинхронную операцию, то нужно использовать действия (actions) в Vuex. Действия похожи на мутации, но они могут содержать асинхронный код и затем вызывают мутации для фактического изменения состояния
```
// в store.js
export default new Vuex.Store({
  state: {
    data: null
  },
  mutations: {
    setData(state, data) {
      state.data = data;
    }
  },
  actions: {
    fetchData({ commit }) {
      return axios.get('api/data')
        .then(response => {
          commit('setData', response.data);
        })
    }
  }
});
```
Здесь у нас есть действие `fetchData`, которое выполняет асинхронный запрос к API, а затем вызывает мутацию `setData` для обновления состояния.

## Как вы оптимизируете веб-сайт или приложение с точки зрения производительности?
Оптимизация производительности приложения на Vue.js - это важная задача, которая может значительно улучшить пользовательский опыт. Вот несколько стратегий для оптимизации Vue.js:

1. **Lazy loading и Code Splitting:** Использование динамических импортов в Vue.js позволяет разделить код на отдельные бандлы, которые загружаются только при необходимости. Это может значительно улучшить время загрузки приложения.
2. **Оптимизация рендеринга компонентов:** Используйте `v-if` вместо `v-show` для условного рендеринга контента, который не всегда нужен. Также старайтесь уменьшить количество слушателей событий и наблюдателей, и избегайте ненужного рендеринга с помощью `Vue.component()` и `Vue.extend()`.
3. **Используйте ключи `v-for`:** Когда вы используете `v-for` для генерации списка, всегда укажите уникальный ключ `:key`. Это помогает Vue.js отслеживать каждый узел в списке и эффективно применять изменения при перерисовке списка.
4. **Применяйте computed свойства:** Вычисляемые свойства (computed properties) очень эффективны, поскольку они кешируются и пересчитываются только при изменении зависимостей.
5. **Избегайте ненужных вычислений в шаблонах:** Логика в шаблонах должна быть минимальной. Если есть вычисления, которые могут быть дорогостоящими с точки зрения производительности, их лучше вынести в методы или computed свойства.
6. **Используйте `v-once` для статического контента:** `v-once` указывает Vue.js, что контент или компонент не будет меняться, и его можно рендерить только один раз.
7. **Профилирование и анализ:** Используйте инструменты, такие как Vue DevTools, для профилирования и анализа производительности вашего приложения. Это поможет вам идентифицировать области, которые могут быть оптимизированы.
8. **Оптимизация CSS и изображений:** Удалите неиспользуемый CSS, минимизируйте CSS и JavaScript, оптимизируйте изображения и используйте форматы изображений сжатия для веб-страниц, чтобы уменьшить общий размер файлов.
9. **Используйте SSR или Prerendering:** Для больших приложений, серверный рендеринг (SSR) или предварительный рендеринг могут значительно ускорить первую загрузку страницы.

## Как загрузить компонент единожды? 
Директива `v-once` в Vue.js является наиболее прямым способом рендеринга компонента единожды, что означает, что после его исходного рендеринга он больше не будет обновляться в ответ на изменения данных.

Однако, есть другие методы, которые можно использовать для достижения схожего эффекта, в зависимости от конкретных потребностей:

1. **Использование вычисляемых свойств (Computed properties):** Вычисляемые свойства реагируют только на изменения своих зависимостей. Таким образом, если вы рендерите данные, которые зависят от вычисляемого свойства, и это свойство не меняется, компонент не будет повторно рендерится.
2. **Использование статического ключа с v-for:** Если вы используете v-for для рендеринга списка компонентов, вы можете предотвратить повторный рендеринг отдельных элементов списка, используя статический ключ. Это может быть полезно, когда вам нужно рендерить большой список и вы хотите предотвратить повторный рендеринг элементов, которые не меняются.
3. **Использование методов жизненного цикла компонента:** Vue предоставляет несколько хуков жизненного цикла, таких как `created`, `mounted`, `updated` и `destroyed`. Вы можете использовать эти хуки, чтобы управлять тем, как и когда компонент обновляется. Например, вы можете загрузить данные в хуке `created` или `mounted` и затем использовать эти данные для исходного рендеринга, не обновляя их позже.

Обратите внимание, что эти методы являются альтернативами `v-once` и они могут не быть подходящими во всех ситуациях. Выбор подхода зависит от конкретного случая использования и требований к производительности вашего приложения.

## Computed 
Computed (вычисляемые) свойства в Vue.js используются для выполнения логики, которая требует некоторых вычислений или обработки, основанных на реактивных данных.

Основное преимущество использования вычисляемых свойств заключается в их способности кеширования результатов. Это означает, что вычисляемое свойство не будет пересчитываться каждый раз, когда происходит рендеринг компонента, вместо этого оно будет пересчитываться только тогда, когда изменяются его зависимости.

Эта особенность делает вычисляемые свойства идеальными для "затратных" операций, то есть операций, которые требуют значительного объема ресурсов для выполнения. Например, если у вас есть массив данных и вам нужно вывести отфильтрованный список, или выполнить сложные математические вычисления на основе этих данных, использование вычисляемых свойств может улучшить производительность вашего приложения, поскольку эти операции будут выполняться только тогда, когда изменяются исходные данные.

Для сравнения, если бы вы использовали методы или вычисляли данные в шаблоне, эти вычисления бы выполнялись каждый раз, когда Vue обновляет DOM, что может привести к ненужному использованию ресурсов и замедлению приложения.
***
## toRef()
`toRef` является функцией во Vue 3, представленной в составе Composition API. Она используется для создания реактивной ссылки (reactive reference) на свойство объекта.

Рассмотрим следующий пример:
```
let state = reactive({ count: 0 })
let count = toRef(state, 'count')

console.log(count.value) // 0
```
`state` является реактивным объектом, и мы хотим использовать свойство `count` отдельно. Здесь мы используем `toRef`, чтобы создать реактивную ссылку на свойство `count`.

Важно отметить, что `count` продолжает быть реактивным и связанным со свойством `count` исходного объекта `state`. Это значит, что при изменении значения `count`, оно также изменится в исходном объекте `state`, и наоборот.
 
Это может быть полезно, когда вы хотите работать с определенным свойством реактивного объекта, но хотите сохранить реактивность и связанность с исходным объектом.