TypeScript поддерживает множество типов данных, включая:

- string (строковый тип данных);
- number (числовой тип данных);
- boolean (булевый тип данных);
- object (объектный тип данных);
- array (массивный тип данных);
- tuple (кортежный тип данных);
- enum (перечисляемый тип данных);
- any (любой тип данных);
- void (отсутствие типа данных);
- null (ничего или отсутствие значения);
- undefined (неопределенный тип данных);
- never (тип данных, который никогда не должен возникать).
***
# Декораторы
— это специальные функции, которые можно применять к классам, методам, свойствам или параметрам. Они позволяют добавлять дополнительное поведение или изменять структуру без изменения самого кода.

Декораторы часто используются в различных фреймворках, таких как Angular, чтобы облегчить разработку и улучшить читаемость кода.

Вот основные виды декораторов в TypeScript:

1. **Декораторы классов**: Применяются непосредственно к конструктору класса.
```
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
  greet() {
    return "Hello, " + this.greeting;
  }
}
```
В этом примере декоратор `@sealed` применяется к классу `Greeter` и запечатывает его, что означает, что к нему нельзя добавить новые свойства.

2. **Декораторы методов**: Применяются к свойствам дескриптора метода.
Вот пример, который логирует вызов метода:
```
function logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function (...args: any[]) {
    console.log(`Called ${propertyKey} with arguments:`, args);
    return originalMethod.apply(this, args);
  };
}

class MyClass {
  @logMethod
  myMethod(a: number, b: number) {
    return a + b;
  }
}

const obj = new MyClass();
obj.myMethod(2, 3); // Выводит: Called myMethod with arguments: [2, 3]

```

3. **Декораторы свойств**: Применяются к свойствам класса.
Декоратор свойства можно использовать для добавления дополнительного поведения при доступе к свойству. Вот пример:
```
function readonly(target: any, propertyKey: string) {
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {};
  descriptor.writable = false;
  Object.defineProperty(target, propertyKey, descriptor);
}

class MyClass {
  @readonly
  myProp: number = 42;
}

const obj = new MyClass();
obj.myProp = 13; // Ошибка: свойство доступно только для чтения

```

4. **Декораторы параметров**: Применяются к параметрам метода или конструктора.
Декоратор параметра можно использовать для добавления метаданных к параметрам метода. Вот пример:
```
const requiredMetadataKey = Symbol("required");

function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
  existingRequiredParameters.push(parameterIndex);
  Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);
}

class MyClass {
  myMethod(@required a: number, b: number) {
    // ...
  }
}
// Можно использовать метаданные для проверки, что параметр передан
```
***
# **Что такое файл объявления в TypeScript и для чего он используется?** 
Файлы объявлений используются, чтобы помочь TypeScript понять формат библиотек, написанных на JavaScript. Они обычно имеют расширение .d.ts.
***
# **Что такое тип `any` в TypeScript?** 
Тип `any` в TypeScript позволяет переменной принимать любой тип данных. Это полезно, когда тип данных неизвестен или может быть разным.
`let variable: any = 'Hello'; variable = 42;  // Это допустимо, поскольку variable имеет тип any`
***
# **Как работают `interface`** 
`interface` используется для определения контракта (или "формы") для объектов. Это позволяет установить определенные правила, которым должны следовать объекты, чтобы соответствовать интерфейсу. Это улучшает безопасность типов и поддерживаемость кода.
```
// Определение интерфейса для описания человека
interface Person {
  firstName: string;
  lastName: string;
  age?: number; // Опциональное свойство
  greet(): void; // Метод
}

// Функция, которая принимает объект, соответствующий интерфейсу Person
function sayHello(person: Person) {
  console.log(`Hello, ${person.firstName} ${person.lastName}!`);
  person.greet();
}

// Объект, соответствующий интерфейсу Person
const john: Person = {
  firstName: "John",
  lastName: "Doe",
  greet: () => console.log("Hi there!")
};

sayHello(john); // Выводит: Hello, John Doe! Hi there!
```
### Особенности `interface`
1. **Опциональные Свойства**: Интерфейс может содержать опциональные свойства, которые могут быть, а могут и не быть в объекте (обозначается знаком `?`).
2. **Реализация Классами**: Классы могут реализовывать интерфейсы, что обеспечивает строгую проверку соответствия структуры класса интерфейсу.
```
class Employee implements Person {
  firstName: string;
  lastName: string;
  greet() {
    console.log("Hello from Employee!");
  }
}
```
3. **Расширение Интерфейсов**: Интерфейсы могут расширять другие интерфейсы, наследуя их свойства и методы.
```
interface Worker extends Person {
  jobTitle: string;
}
```
4. **Индексные Сигнатуры**: Интерфейс может определять индексные сигнатуры для работы с динамическими свойствами.
```
interface StringDictionary {
  [key: string]: string;
}
```
5. **Совмещение Интерфейсов**: Если интерфейс определен несколько раз с одним и тем же именем, его члены объединяются в один интерфейс.

***
# **Что такое `type`**
`type` используется для определения пользовательских типов. Это позволяет создавать сложные типы, комбинировать их и использовать в различных частях кода для улучшения безопасности типов и читаемости.
```
// Определение типа для описания человека
type Person = {
  firstName: string;
  lastName: string;
  age?: number; // Опциональное свойство
};

// Функция, которая принимает объект типа Person
function sayHello(person: Person) {
  console.log(`Hello, ${person.firstName} ${person.lastName}!`);
}

// Объект типа Person
const john: Person = {
  firstName: "John",
  lastName: "Doe"
};

sayHello(john); // Выводит: Hello, John Doe!
```
### Особенности `type`
1. **Алиасы для Примитивных Типов**: Можно создавать алиасы для примитивных типов, что удобно для документирования и повторного использования.
`type UserID = string;`
2. **Объединение и Пересечение**: Можно комбинировать типы с помощью операторов объединения (`|`) и пересечения (`&`).
```
type Animal = Dog | Cat; // Объединение
type Pet = Animal & { name: string }; // Пересечение
```
3. **Литеральные Типы**: Можно определить тип, который принимает только определенные литеральные значения.
`type Direction = "up" | "down" | "left" | "right";`
4. **Индексные Сигнатуры**: Аналогично интерфейсам, можно определить индексные сигнатуры.
```
type StringDictionary = {
  [key: string]: string;
};
```
5. **Маппинг Типов**: Можно создавать новые типы на основе существующих с помощью маппинга.
`type ReadonlyPerson = Readonly<Person>; // Все свойства только для чтения`
6. **Условные Типы**: Можно создавать условные типы, которые выбирают один тип или другой на основе условия.
`type IsString<T> = T extends string ? true : false;`
***
# **Что такое алиасы?**
представляют собой именованные ссылки или "короткие имена" для типов. Они позволяют создать пользовательское имя для существующего типа, что может улучшить читаемость кода и облегчить его поддержку.
### Пример Алиаса в TypeScript
```
// Определение алиаса для типа, представляющего идентификатор пользователя
type UserID = string;

// Функция, которая принимает алиас типа в качестве параметра
function getUser(id: UserID) {
  // ...
}
```
### Преимущества Алиасов

1. **Читаемость**: Алиасы могут сделать код более понятным, давая осмысленные имена типам, которые отражают их использование в вашем приложении.
2. **Повторное Использование**: Если у вас есть сложный тип, который используется во многих местах, алиас позволяет определить его один раз и затем использовать во всем коде.
3. **Рефакторинг**: Если вам нужно изменить тип в будущем, алиас позволяет сделать это в одном месте, а не в каждом месте, где тип используется.
4. **Комбинирование Типов**: Алиасы могут быть использованы для создания сложных типов с использованием объединений, пересечений и других возможностей TypeScript.
***
# **В чём отличия типов от интерфейсов?**
Денис, отлично, что ты задаёшь этот вопрос! В TypeScript типы (`type`) и интерфейсы (`interface`) имеют много общего, но есть и ключевые различия. Вот основные из них:

### 1. Расширение и Объединение
- **Интерфейсы**: Могут быть расширены с помощью ключевого слова `extends`. Если интерфейс определен несколько раз с одним и тем же именем, его члены объединяются в один интерфейс.
```
interface A { x: number; }
interface A { y: number; } // Объединяется с предыдущим интерфейсом A
```   
- **Типы**: Не могут быть объединены под одним именем. Однако они могут использовать операторы пересечения (`&`) и объединения (`|`) для комбинирования типов.

### 2. Реализация в Классах
- **Интерфейсы**: Могут быть реализованы в классах с помощью ключевого слова `implements`.
```
interface Person { name: string; }
class User implements Person { name = "John"; }
```   
- **Типы**: Не могут быть явно реализованы в классах (хотя можно проверить соответствие типу).

### 3. Определение Формы Объекта
- **Интерфейсы**: Идеально подходят для определения формы объекта, включая опциональные свойства, индексные сигнатуры и т.д.
- **Типы**: Также могут определять форму объекта, но обладают большей гибкостью в определении сложных и комбинированных типов.

### 4. Литеральные и Вычисляемые Типы
- **Интерфейсы**: Ограничены в использовании литеральных и вычисляемых типов.
- **Типы**: Поддерживают литеральные типы, условные типы, маппинг типов и другие сложные конструкции.

### 5. Видимость
- **Интерфейсы**: Создают именованное объявление, которое можно найти при навигации по коду.
- **Типы**: Алиасы типов являются анонимными, и их имя не появляется в сообщениях об ошибках или при навигации.
***
# **В чём отличие `type` от `interface`?**
### 1. Расширение и Объединение
- **Интерфейсы**: Могут быть расширены с помощью ключевого слова `extends`. Если интерфейс определен несколько раз с одним и тем же именем, его члены объединяются в один интерфейс.
```
interface A { x: number; }
interface A { y: number; } // Объединяется с предыдущим интерфейсом A
```
- **Типы**: Не могут быть объединены под одним именем. Однако они могут использовать операторы пересечения (`&`) и объединения (`|`) для комбинирования типов.

### 2. Реализация в Классах
- **Интерфейсы**: Могут быть реализованы в классах с помощью ключевого слова `implements`.
```
interface Person { name: string; }
class User implements Person { name = "John"; }
```
- **Типы**: Не могут быть явно реализованы в классах (хотя можно проверить соответствие типу).

### 3. Определение Формы Объекта
- **Интерфейсы**: Идеально подходят для определения формы объекта, включая опциональные свойства, индексные сигнатуры и т.д.
- **Типы**: Также могут определять форму объекта, но обладают большей гибкостью в определении сложных и комбинированных типов.

### 4. Литеральные и Вычисляемые Типы
- **Интерфейсы**: Ограничены в использовании литеральных и вычисляемых типов.
- **Типы**: Поддерживают литеральные типы, условные типы, маппинг типов и другие сложные конструкции.

### 5. Видимость
- **Интерфейсы**: Создают именованное объявление, которое можно найти при навигации по коду.
- **Типы**: Алиасы типов являются анонимными, и их имя не появляется в сообщениях об ошибках или при навигации.

### Заключение
Выбор между `type` и `interface` зависит от конкретного случая использования. Если вам нужно определить контракт объекта, который может быть реализован классами, интерфейсы могут быть лучшим выбором. Если вам нужна большая гибкость в определении сложных или комбинированных типов, алиасы типов могут быть более подходящими.
***
В TypeScript, `Pick`, `Omit`, и `ReturnType` являются утилитными типами, которые позволяют манипулировать типами в различных сценариях. Вот как они работают:

# `Pick`, `Omit`, и `ReturnType`
В TypeScript, `Pick`, `Omit`, и `ReturnType` являются утилитными типами, которые позволяют манипулировать типами в различных сценариях. Вот как они работают:
### 1. `Pick<Type, Keys>`

`Pick` создает новый тип, выбирая подмножество свойств из существующего типа.

```typescript
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = Pick<Todo, "title" | "completed">;

const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
};

// `todo` теперь имеет только свойства `title` и `completed`.
```

### 2. `Omit<Type, Keys>`

`Omit` создает новый тип, исключая указанные свойства из существующего типа.

```typescript
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoInfo = Omit<Todo, "completed">;

const todoInfo: TodoInfo = {
  title: "Pick up kids",
  description: "Pick up kids from school",
};

// `todoInfo` теперь не имеет свойства `completed`.
```

### 3. `ReturnType<Type>`

`ReturnType` извлекает тип возвращаемого значения функции.

```typescript
type T0 = ReturnType<() => string>;  // string
type T1 = ReturnType<(s: string) => void>;  // void
type T2 = ReturnType<<T>() => T>;  // {}
type T3 = ReturnType<<T extends U, U extends number[]>() => T>;  // number[]
type T4 = ReturnType<typeof Math.random>;  // number
```

Эти утилитные типы очень полезны для создания новых типов на основе существующих, что делает ваш код более гибким и поддерживаемым.

Подробнее о утилитных типах можно прочитать в [официальной документации TypeScript](https://www.typescriptlang.org/docs/handbook/utility-types.html).
***
# **Как код TypeScript трансформируется в Js?** 
### 1. Удаление Типов и Сигнатур
TypeScript добавляет строгую типизацию, которая не существует в чистом JavaScript. Поэтому первым шагом компиляции является удаление всех типов и сигнатур.

**TypeScript:**
```
function add(a: number, b: number): number {
  return a + b;
}
```
**JavaScript:**
```
function add(a, b) {
  return a + b;
}
```

### 2. Преобразование Синтаксических Конструкций
Некоторые синтаксические конструкции TypeScript не имеют прямого аналога в JavaScript, поэтому они преобразуются в эквивалентный код.

**TypeScript (использование `enum`):**
`enum Colors {Red, Green, Blue}`

**JavaScript:**
```
var Colors;
(function (Colors) {
  Colors[Colors["Red"] = 0] = "Red";
  Colors[Colors["Green"] = 1] = "Green";
  Colors[Colors["Blue"] = 2] = "Blue";
})(Colors || (Colors = {}));
```
### **Декораторы**
Декораторы — это экспериментальная возможность TypeScript, которая позволяет добавлять метаданные к классам и их членам. Они преобразуются в вызовы функций в JavaScript.

**TypeScript:**
```
@decorator
class MyClass { }
```
**JavaScript:**
`var MyClass = decorator(class MyClass { });`

### **Пространства Имен**
Пространства имен в TypeScript позволяют организовать код в логические группы. Они преобразуются в немедленно вызываемые функциональные выражения (IIFE) в JavaScript.

**TypeScript:**
```
namespace MyNamespace {
  export const x = 10;
}
```
**JavaScript:**
```
var MyNamespace;
(function (MyNamespace) {
  MyNamespace.x = 10;
})(MyNamespace || (MyNamespace = {}));
```

**Типы и Интерфейсы**

Так как JavaScript не имеет встроенной системы типов, все объявления типов и интерфейсов удаляются из итогового JavaScript-кода.

**TypeScript:**
```
type MyType = number;
interface MyInterface { prop: string; }
```
**JavaScript:**
`// Нет эквивалентного кода в JavaScript`

### 3. Транспиляция Версий ECMAScript
TypeScript поддерживает новые возможности ECMAScript, которые могут быть не поддерживаемы в некоторых средах выполнения. Компилятор может транспилировать код в более старую версию ECMAScript для обеспечения совместимости.

**TypeScript (использование стрелочных функций и `const`):**
`const greet = (name: string) => `Hello, ${name}!`;`
**JavaScript (ES5):**
```
var greet = function(name) {
  return "Hello, " + name + "!";
};
```

### 4. Конфигурация Компиляции
Файл `tsconfig.json` позволяет настроить процесс компиляции, включая целевую версию ECMAScript, модульный систему, опции строгой проверки и многое другое.

### 5. Интеграция с Средой Разработки
Большинство современных сред разработки поддерживают TypeScript, предоставляя подсказки, проверку типов и другие возможности, которые упрощают разработку и отладку.
***
# **Что такое `enum` и как его использовать?** 
`enum` (перечисление) — это специальный тип в TypeScript, который позволяет определить набор именованных констант. Это удобно для создания группы связанных значений, которые можно использовать в коде для улучшения читаемости и безопасности типов.
```
// Определение перечисления для дней недели
enum Weekday {
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
  Sunday
}

// Использование перечисления
const today: Weekday = Weekday.Monday;

// Функция, которая принимает день недели в качестве аргумента
function isWeekend(day: Weekday): boolean {
  return day === Weekday.Saturday || day === Weekday.Sunday;
}

console.log(isWeekend(today)); // Выводит false
```
## Особенности `enum`
1. **Числовые и Строковые Значения**: По умолчанию значения `enum` являются числовыми, начиная с 0. Вы также можете явно задать числовые или строковые значения:
```
enum Direction {
  Up = 1,
  Down = "DOWN",
  Left = 2,
  Right = "RIGHT"
}
```

2. **Обратный Доступ**: Вы можете получить имя ключа по значению:
`console.log(Weekday[Weekday.Monday]); // Выводит "Monday"`

3. **Константные и Вычисляемые Члены**: `enum` может содержать константные (значения известны на этапе компиляции) и вычисляемые (значения вычисляются во время выполнения) члены.

4. **`const enum`**: Если вы не планируете использовать обратный доступ, вы можете определить перечисление как `const enum`. Это позволит компилятору убрать лишний код и вставить значения напрямую:
```
const enum Colors {
  Red,
  Green,
  Blue
}
console.log(Colors.Red); // Компилируется в console.log(0);
```
***
**Что такое `union` и `intersection` типы в TypeScript?** 
`Union` типы позволяют объявить переменную, которая может содержать один из нескольких типов данных. `Intersection` типы используются для комбинирования нескольких типов в один.
`type StringOrNumber = string | number;  // Union type NameAndId = { name: string } & { id: number };  // Intersection`
***
**Как TypeScript обрабатывает `null` и `undefined`?** 
По умолчанию `null` и `undefined` могут быть присвоены любому типу в TypeScript. Однако, если включена опция компилятора `strictNullChecks`, то `null` и `undefined` могут быть присвоены только к типам `null` и `undefined` соответственно.
***
# **Что такое `generics` в TypeScript?** 
Дженерики (или generics) в TypeScript — это мощный инструмент, который позволяет создавать компоненты, способные работать с различными типами, не теряя при этом информации о типах.
### Пример без дженериков
Предположим, у тебя есть функция, которая принимает массив и возвращает его первый элемент:
```
function getFirstElement(arr: any[]): any {
  return arr[0];
}
```
### Пример с дженериками
```
function getFirstElement<T>(arr: T[]): T {
  return arr[0];
}
```
Здесь `T` — это переменная типа, которая будет определена в момент вызова функции. Таким образом, если ты вызовешь `getFirstElement([1, 2, 3])`, `T` будет автоматически определен как `number`, и весь код будет типизирован правильно.
### Преимущества
- **Гибкость**: Дженерики позволяют писать универсальный код, который может работать с различными типами.
- **Безопасность типов**: Используя дженерики, ты сохраняешь информацию о типах, что позволяет компилятору TypeScript ловить ошибки на этапе компиляции.
***
# Модификаторы доступа
В TypeScript существует четыре основных модификатора доступа, которые определяют, как и где можно использовать классы, методы, свойства и так далее.

1. **`public`**: Этот модификатор делает члены класса доступными из любого места. Если модификатор не указан, по умолчанию используется `public`.
```
class Car {
  public model: string;
  constructor(model: string) {
    this.model = model;
  }
}
```
2. **`private`**: Ограничивает доступ к члену класса, делая его доступным только внутри этого класса.
```
class Car {
  private model: string;
  constructor(model: string) {
    this.model = model;
  }
}
```
3. **`protected`**: Похож на `private`, но члены, объявленные как `protected`, доступны также в подклассах.
```
class Vehicle {
  protected type: string;
  constructor(type: string) {
    this.type = type;
  }
}

class Car extends Vehicle {
  private model: string;
  constructor(model: string) {
    super('car');
    this.model = model;
  }
}
```
4. **`readonly`**: Этот модификатор делает свойство только для чтения. Оно должно быть инициализировано при объявлении или в конструкторе.
```
class Car {
  readonly model: string;
  constructor(model: string) {
    this.model = model;
  }
}
```

***
**Что такое Tuple?** 
`Tuple` позволяет указать тип каждого элемента массива. Это полезно, когда массив представляет собой совокупность различных типов.
`let x: [string, number]; x = ["hello", 10]; // OK`
***
**Как можно привести типы в TypeScript?** 
Приведение типов можно сделать с использованием угловых скобок или оператора `as`.
`let someValue: any = "this is a string"; let strLength: number = (<string>someValue).length; // или let strLength: number = (someValue as string).length;`
***
 **Что такое модули в TypeScript?** 
 Модули используются для организации и инкапсуляции кода. Модули в TypeScript можно импортировать и экспортировать с использованием ключевых слов `import` и `export`.
    `// someModule.ts export const someValue = 42; // someOtherModule.ts import { someValue } from './someModule';`
***
**Что такое наследование в TypeScript?** 
Наследование - это ключевой принцип объектно-ориентированного программирования, который TypeScript поддерживает с использованием ключевых слов `extends` и `super`.
``class Animal {   move(distanceInMeters: number = 0) {     console.log(`Animal moved ${distanceInMeters}m.`);   } }  class Dog extends Animal {   bark() {     console.log('Woof! Woof!');   } }``
***
**Что такое `ReadonlyArray<T>` в TypeScript?** 
 `ReadonlyArray<T>` - это массив, который нельзя изменить после его создания. Это полезно для предотвращения мутаций в массиве.
`let a: ReadonlyArray<number> = [1, 2, 3, 4];`
***
**Что такое `namespace` в TypeScript?** 
`namespace` используются для группировки кода и избегания конфликтов имен. `namespace` может содержать классы, функции, переменные и другие `namespace`.
***
**Что такое Promise в TypeScript?** Promise в TypeScript представляет собой объект, используемый для асинхронного вычисления. Promise может быть в трех состояниях: pending, fulfilled и rejected.
`const promise = new Promise<string>((resolve, reject) => {   setTimeout(() => {     resolve("Promise resolved")   }, 2000) });`
***
**Как вы обрабатываете ошибки в TypeScript?** Обработка ошибок в TypeScript обычно выполняется с использованием блоков `try/catch`. Также можно использовать `.catch()` метод с Promise.
***
**Что такое Map и Set в TypeScript?** `Map` и `Set` - это новые структуры данных в ES6, которые также поддерживаются в TypeScript. `Map` - это коллекция ключ/значение, а `Set` - это коллекция уникальных элементов.
***
**Что такое деструктуризация в TypeScript?** Деструктуризация - это ES6-функция, которую TypeScript поддерживает. Он позволяет извлекать данные из массивов или объектов с использованием синтаксиса, который зеркалирует конструкцию массивов и объектов.
 `let { a, b }: { a: string, b: number } = { a: "baz", b: 101 };`


