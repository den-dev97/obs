## Типы  данных:
	1. String 
	2. Number (Целочесленные, с плавающей точкой. Диапозон: от -9 007 199 254 740 991 до 9007199254740991)
		1. Infinity (Математическая бесконечность. Получить: 1/0, или задать его явно)
		2. NaN (Означает вычислительную ошибку 'string'/2)
	3. BigInt
	4. Boolean
	5. Null - typeof(null) // Object - ошибка, допущеная создателем JS
	6. Undefined
	7. Symbol
	8. Object - подтип: function 

## Методы [ ]
	1. arr.push(...items) – добавляет элементы в конец,
	2. arr.pop() – извлекает элемент из конца,
	3. arr.shift() – извлекает элемент из начала,
	4. arr.unshift(...items) – добавляет элементы в начало.
	5. arr.splice(1, 1, ...items); - начиная с индекса 1, удалить 1 элемент, вставить items
	6. arr.slice([start], [end]) - return new arr, в который копирует все элементы с индекса start до end. arr.slice() создаёт копию []
	7. arr.concat(arg1, arg2...) create new [], в который копирует данные из других [] и дополнительные значения.
	8. arr.forEach(function(item, index, array) { // ... делать что-то с item }) позволяет запускать функцию для каждого элемента массива.
	9. arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
	10. arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
	11. arr.find(function(item, index, array) { // если true - возвращается первый элемент и перебор прерывается, иначе возвращается undefined });
	12. arr.findIndex(function(item, index, array) { // начинается поиск с начала, возвращается индекс, иначе возвращается -1 });
	13. arr.findLastIndex(function(item, index, array) { // начинается поиск с конца, возвращается индекс, иначе возвращается -1 });
	14. arr.filter // let results = arr.filter(function(item, index, array) { // если `true` -- элемент добавляется к results и перебор продолжается // возвращается [] в случае, если ничего не найдено });
	15. arr.map // Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции. let result = arr.map(function(item, index, array) { // возвращается новое значение вместо элемента });
	16. arr.sort() // сортирует массив на месте, меняя в нём порядок элементов.
	17. arr.reverse() - меняет порядок элементов в arr на обратный
	18. arr.split() - разбивает строку по заданному разделителю и возвращает массив элементов
	19. arr.join() - склеивает массив в строку по указанному разделителю 
	20. arr.reduce() - используются для вычисления единого значения с начала [] на основе всего массива arr.reduce(function(accumulator, item, index, array) { // ... }, [initial]) let result = arr.reduce((sum, current) => sum + current, 0)
	21. arr.reduce() - используются для вычисления единого значения с конца [] на основе всего массива arr.reduce(function(accumulator, item, index, array) { // ... }, [initial]) let result = arr.reduce((sum, current) => sum + current, 0)
***
## Различия let const и var
В JavaScript, `var`, `let` и `const` - это три способа объявления переменных, каждый из которых имеет свои особенности.
**var**:
- `var` объявляет переменную в рамках области видимости функции, если она объявлена внутри функции. Если `var` объявлена вне функции, то она становится глобальной переменной.
- Переменные, объявленные с использованием `var`, поднимаются (hoisting) к началу своей области видимости. Это означает, что переменная может быть объявлена после того, как она была использована.
- Переменные, объявленные как `var`, могут быть переопределены.
**let**:
- `let` объявляет переменную в рамках блочной области видимости. Это означает, что переменная, объявленная внутри блока кода (например, внутри цикла или условного оператора), не существует за пределами этого блока.
- Переменные, объявленные как `let`, не поднимаются к началу своей области видимости.
- Переменные, объявленные как `let`, могут быть переопределены в рамках своей области видимости.
**const**:
- `const` также объявляет переменную в рамках блочной области видимости, как и `let`.
- Переменные, объявленные как `const`, не поднимаются к началу своей области видимости.
- Переменные, объявленные как `const`, не могут быть переопределены. Это означает, что после их инициализации, вы не можете изменить их значение. Это делает `const` хорошим выбором для переменных, значение которых не должно меняться.
В общем, если вам не нужно переопределять переменную и она не должна меняться, используйте `const`. Если вам нужна переменная, которую можно переопределить, используйте `let`. Использование `var` стало менее распространенным из-за его свойств, которые могут привести к ошибкам и трудностям в отладке.
***
## **Архитектуры бывают:**
1. **Монолитная архитектура (Monolithic Architecture)**: В этой архитектуре вся система представляет собой единое целое, где все компоненты приложения разворачиваются и работают вместе на одном сервере или в одном контейнере. Все функциональные модули и компоненты обычно связаны и зависят друг от друга.
2. **Клиент-серверная архитектура (Client-Server Architecture)**: Как уже упоминалось ранее, клиент-серверная архитектура разделяет функциональность системы между клиентами и серверами. Клиенты отправляют запросы на сервер для получения данных или услуг, и серверы обрабатывают эти запросы и предоставляют соответствующие данные или услуги клиентам.
3. **Распределенная архитектура (Distributed Architecture):** В распределенной архитектуре различные компоненты системы выполняются на нескольких физических или логических узлах, которые могут находиться в разных сетях или местоположениях. Коммуникация между компонентами осуществляется через сеть.
4. **Микросервисная архитектура (Microservices Architecture)**: В этой архитектуре приложение разбивается на множество маленьких и независимых микросервисов, которые работают вместе. Каждый микросервис представляет собой отдельную и самодостаточную часть приложения, которая имеет свою собственную базу кода, базу данных и коммуникацию с другими микросервисами.
5. **Событийно-ориентированная архитектура (Event-Driven Architecture):** В этой архитектуре система строится вокруг потоков событий и реакции на эти события. Различные компоненты системы могут отправлять и получать события, и на них можно реагировать для выполнения определенных действий.
6. **Service-Oriented Architecture (SOA):** В SOA приложение разбивается на сервисы, которые предоставляют конкретные функциональные возможности. Эти сервисы могут быть использованы другими приложениями через унифицированный интерфейс.
7. **Serverless Architecture:** В этой архитектуре разработчики фокусируются на функциональных блоках кода (функциях) и не беспокоятся о поддержке и управлении серверной инфраструктурой. Функции запускаются автоматически в ответ на события или запросы.
***
## **RESTful (Representational State Transfer)** 
- это архитектурный стиль для разработки веб-сервисов, который опирается на принципы и ограничения веб-протокола HTTP. Он описывает подход к проектированию и организации взаимодействия между клиентом и сервером.

Основные принципы RESTful-архитектуры:
1. **Ресурсы (Resources)**: В REST, данные или сервисы, которые приложение может использовать, называются ресурсами. Каждый ресурс идентифицируется с помощью уникального URL (Uniform Resource Locator), который является "адресом" ресурса.
2. **HTTP-методы (HTTP Methods)**: REST использует стандартные HTTP-методы для работы с ресурсами. Это включает в себя GET (получение данных), POST (создание новых данных), PUT (обновление существующих данных) и DELETE (удаление данных).
3. **Стандартные форматы данных**: REST API обычно используют стандартные форматы данных, такие как JSON (JavaScript Object Notation) или XML (eXtensible Markup Language) для отправки и получения данных.
4. **Stateless (Без сохранения состояния)**: Одной из ключевых особенностей REST является то, что сервер не сохраняет информацию о состоянии между различными запросами. Это означает, что каждый запрос должен содержать всю необходимую информацию для его обработки.
5. **Client-Server Architecture (Архитектура клиент-сервер)**: REST API основаны на архитектуре клиент-сервер, где клиент (обычно веб-браузер или другое приложение) отправляет запросы на сервер, который обрабатывает эти запросы и возвращает ответы обратно клиенту.
6. **Cacheable (Кешируемость)**: Ответы от сервера могут быть кешированы (или сохранены) на стороне клиента для улучшения производительности.

RESTful-сервисы организуют данные в виде ресурсов, которые могут быть идентифицированы уникальными URI. Клиенты могут выполнять операции над этими ресурсами, отправляя запросы HTTP на соответствующие URI, используя соответствующие методы (GET, POST, PUT, DELETE) и передавая данные, когда это необходимо.
Каждая архитектура имеет свои особенности, преимущества и ограничения. Выбор подходящей архитектуры зависит от множества факторов, таких как требования проекта, масштабируемость, доступность, безопасность и простота разработки и поддержки системы.
***
## HTTP-запрос
HTTP запрос можно осуществить различными способами:
1. Fetch API: Предоставляет простой и мощный интерфейс для выполнения HTTP-запросов. Поддерживается в современных браузерах.
2. XMLHttpRequest (XHR): Старый, но все еще широко используемый способ выполнения асинхронных запросов на сервер. Поддерживается во всех современных браузерах.
3. Axios: Библиотека для выполнения HTTP-запросов, предоставляющая удобный API для выполнения запросов как в браузере, так и на сервере.
4. jQuery AJAX: jQuery - это JavaScript-библиотека, которая предоставляет удобные методы для выполнения AJAX-запросов.
5. Superagent: Легковесная библиотека для выполнения запросов на сервер с поддержкой промисов.
6. node-fetch: Библиотека для выполнения запросов на сервер в Node.js, основанная на Fetch API.
7. got: Мощная библиотека для выполнения HTTP-запросов с поддержкой промисов и потоковых данных.
8. reqwest: Простая и легковесная библиотека для выполнения AJAX-запросов в браузере.
9. Angular HttpClient: Модуль Angular для выполнения HTTP-запросов в браузере.
10. Vue Resource: Официальный HTTP-клиент Vue.js для выполнения запросов на сервер.
11. Ember Data: Библиотека для работы с данными и выполнения запросов на сервер в фреймворке Ember.js.
12. Meteor HTTP: Встроенный модуль в платформе Meteor для выполнения HTTP-запросов на сервер.
	HTTP-запрос — это сообщение, которое отправляется клиентом (обычно браузером) на сервер в процессе обмена данными по протоколу **HTTP (Hypertext Transfer Protocol)**, который является основой любого обмена данными в Интернете.
	HTTP-запросы состоят из различных частей, включая:
	1. **Метод запроса**: Это тип операции, который клиент хочет выполнить. Существует несколько методов HTTP, включая GET (запрос данных от сервера), POST (отправка данных на сервер), PUT (обновление существующих данных на сервере), DELETE (удаление данных на сервере) и другие.
	2. **URL (Uniform Resource Locator)**: URL определяет, куда направить запрос. Это может включать доменное имя сервера и путь к конкретному ресурсу на сервере.
	3. **Заголовки**: Заголовки могут содержать различные метаданные о запросе, такие как тип содержимого, кодировку, куки и другие данные.
	4. **Тело запроса**: Некоторые методы HTTP (например, POST и PUT) могут включать тело запроса, которое содержит данные, отправляемые на сервер. В запросах с методом GET тела нет.
Вот наиболее распространенные HTTP-методы и их назначение:
1. **GET**: Используется для получения данных с сервера. Запросы GET не должны изменять состояние сервера и могут содержать параметры в URL-адресе.
```
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => { console.log(data); // Получение данных с сервера })
  .catch(error => { console.error(error) });
```
2. **POST**: Используется для отправки данных на сервер для создания новых ресурсов. POST-запросы могут содержать данные в теле запроса и обычно приводят к изменению состояния сервера.
```
const newData = { name: 'John', age: 30 };

fetch('https://api.example.com/data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(newData)
})
  .then(response => response.json())
  .then(data => { console.log(data); // Создание нового ресурса на сервере })
  .catch(error => { console.error(error) });
```
3. **PUT**: Используется для отправки данных на сервер с целью полного обновления существующего ресурса. PUT-запросы содержат данные в теле запроса и перезаписывают текущую версию ресурса.
```
const updatedData = { name: 'John Doe', age: 35 };

fetch('https://api.example.com/data/1', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(updatedData)
})
  .then(response => response.json())
  .then(data => { console.log(data) // Обновление существующего ресурса на сервере })
  .catch(error => { console.error(error) });
```
4. **PATCH**: Используется для отправки данных на сервер с целью частичного обновления существующего ресурса. PATCH-запросы содержат данные в теле запроса и применяют изменения к текущей версии ресурса.
5. **DELETE**: Используется для удаления существующего ресурса на сервере.
```
fetch('https://api.example.com/data/1', {  method: 'DELETE' })
  .then(response => { console.log('Ресурс успешно удален') })
  .catch(error => { console.error(error) });
```
6. **OPTIONS**: Используется для получения информации о доступных опциях или методах, поддерживаемых сервером для определенного ресурса.
7. **HEAD**: Похож на GET-запрос, но возвращает только заголовки ответа, без фактического содержимого.
8. **TRACE**: Используется для эхо-тестирования, когда сервер возвращает входящий запрос в виде ответа, позволяя клиенту видеть, как его запросы проходят через различные системы.
9. **CONNECT**: Используется для установки соединения с сервером через прокси.
***
## **Помимо HTTP есть так же:**
1. **HTTPS (HyperText Transfer Protocol Secure)**: Это просто HTTP, но с добавленным слоем безопасности SSL (Secure Sockets Layer) или TLS (Transport Layer Security), которые шифруют данные, передаваемые между клиентом и сервером.
2. **FTP (File Transfer Protocol)**: Этот протокол используется для передачи файлов между клиентом и сервером. Он поддерживает передачу больших файлов и может быть настроен для работы в активном или пассивном режиме.
3. **SMTP (Simple Mail Transfer Protocol)**: Этот протокол используется для отправки электронной почты. Обычно SMTP используется для отправки сообщений, в то время как POP3 или IMAP используются для их получения.
4. **WebSockets**: Этот протокол обеспечивает двустороннее взаимодействие между клиентом и сервером в режиме реального времени. Он был разработан для решения проблем, с которыми столкнулись разработчики, пытающиеся реализовать сложные веб-приложения с использованием HTTP.
5. **gRPC (Google Remote Procedure Call)**: Этот протокол, разработанный Google, использует протокол HTTP/2 и поддерживает множество языков программирования. Он использует Protobuf (Protocol Buffers) для эффективной сериализации структурированных данных и поддерживает функции, такие как аутентификация, нагрузочное балансирование и отмена запросов.
6. **MQTT (Message Queuing Telemetry Transport)**: Это протокол передачи сообщений, который часто используется в системах IoT (Internet of Things) для обмена данными между устройствами с низкими требованиями к пропускной способности и энергопотреблению.
***
## **Что такое замыкание (closure) в JavaScript?**
Замыкание в JavaScript - это особенность, которая позволяет функции сохранять информацию о переменных, которые были доступны в момент её создания. Это означает, что функция может использовать эти переменные, даже если они уже не существуют в области видимости.
```
function outerFunction() {
  let counter = 0;
  return function () {
    counter++
    console.log(counter);
  }
}
let closureExample = outerFunction();
closureExample(); // 1 closureExample(); // 2

function multiply(a) {
  return function(b) {
    return a * b
  }
}
const multiplyByTwo = multiply(2) console.log(multiplyByTwo(2)) // 4
const multiplyByTree = multiply(3) console.log(multiplyByTree(3)) // 9

```
Замыкания полезны во многих случаях, например, при создании приватных переменных и функций, при реализации модульного паттерна или при работе с асинхронным кодом, чтобы сохранить состояние между вызовами функций.
***
## **Что такое Map и Set**
`Map` и `Set` являются двумя встроенными коллекциями в JavaScript, которые предоставляют удобные способы хранения и организации данных.

#### `Map` 
представляет собой коллекцию пар "ключ-значение". Ключи в `Map` могут быть любого типа данных, включая примитивы и объекты. Значения также могут быть любого типа данных. Основные особенности `Map`:

- Гарантирует уникальность ключей. Если попытаться добавить в `Map` значение с уже существующим ключом, старое значение будет заменено новым.
- Поддерживает итерацию по парам "ключ-значение" с помощью метода `forEach` или оператора `for...of`.
- Можно использовать любые типы данных в качестве ключей.
- Предоставляет методы для добавления, удаления и обновления пар "ключ-значение", а также для получения размера `Map` и проверки наличия определенного ключа.

Пример использования `Map`:
```
const map = new Map();

map.set("name", "John");
map.set("age", 30);

console.log(map.get("name")); // Выводит "John"
console.log(map.size); // Выводит 2

map.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

map.delete("age");
console.log(map.has("age")); // Выводит false
```

#### `Set` 
представляет собой коллекцию уникальных значений любого типа данных. Основные особенности `Set`:

- Хранит только уникальные значения. При попытке добавить в `Set` уже существующее значение, оно будет проигнорировано.
- Поддерживает итерацию по значениям с помощью метода `forEach` или оператора `for...of`.
- Можно использовать любые типы данных в качестве значений.

Пример использования `Set`:
```
const set = new Set();

set.add("apple");
set.add("banana");
set.add("apple"); // Дубликат "apple" будет проигнорирован

console.log(set.size); // Выводит 2

set.forEach(value => {
  console.log(value);
});

set.delete("banana");
console.log(set.has("banana")); // Выводит false
```
Вот основные отличия между `Map` и `Set`:

1. Уникальность элементов: `Map` сохраняет уникальные пары "ключ-значение", тогда как `Set` хранит только уникальные значения.
2. Тип данных ключа: В `Map` ключами могут быть любые типы данных, включая примитивы и объекты. В `Set` значениями могут быть любые типы данных, но ключи и значения идентичны.
3. Итерация: `Map` предоставляет методы для итерации по парам "ключ-значение" с помощью `forEach` или `for...of`, в то время как `Set` позволяет итерироваться только по значениям.
4. Размер: `Map` имеет свойство `size`, которое возвращает количество пар "ключ-значение" в коллекции. У `Set` также есть свойство `size`, которое возвращает количество уникальных значений в коллекции.
5. Удаление элементов: В `Map` элементы можно удалить с помощью метода `delete`, передавая ключ в качестве аргумента. В `Set` элементы также удаляются с помощью метода `delete`, но в качестве аргумента передается значение.
6. Порядок элементов: `Map` сохраняет порядок добавления пар "ключ-значение". Это означает, что при итерации элементы будут возвращаться в том же порядке, в котором они были добавлены. В `Set` порядок элементов определяется порядком их добавления, но он не гарантирован и может быть изменен внутренней реализацией JavaScript.

Оба `Map` и `Set` предоставляют эффективные методы для добавления, удаления и поиска элементов. Выбор между `Map` и `Set` зависит от специфических потребностей вашего приложения и типа данных, которые вы хотите хранить. Если вам нужно хранить пары "ключ-значение" или требуется быстрый поиск по ключу, то `Map` будет предпочтительнее. Если вам нужно хранить только уникальные значения и вам не важен порядок, то `Set` будет более подходящим выбором.
Использование `Map` и `Set` позволяет эффективно хранить и манипулировать данными, обеспечивая быстрый доступ и уникальность значений или пар "ключ-значение". Выбор между `Map` и `Set` зависит от конкретных потребностей и требований вашего приложения.
* * *
## Event Loop 
- это концепция, лежащая в основе асинхронного программирования, которая позволяет JavaScript выполнять неблокирующие операции, несмотря на то, что сам язык является однопоточным.
В общем виде, Event Loop, или цикл событий, следует следующим этапам:

1. **Call Stack (Стек вызовов)**: Это место, где выполняется ваш JavaScript код. Когда функция вызывается, она помещается на вершину стека вызовов. Когда функция завершена, она удаляется из стека.
2. **Wep Apis**: Это структура данных, которая представляет большую область памяти, где осуществляется выделение памяти для объектов JavaScript.
3. **Callback Queue (Очередь обратного вызова)**: Это список задач, которые ожидают выполнения. Когда асинхронная функция завершает свою работу (например, Ajax-запрос, таймер и т.д.), она добавляет новую задачу в очередь.

Сам Event Loop делает следующее:

1. Проверяет, есть ли в стеке вызовов какие-либо функции для выполнения. Если есть, он запускает их одну за другой, пока стек не опустеет.
2. Когда стек пуст, он смотрит на очередь задач. Если в очереди есть задачи, Event Loop берет первую задачу из очереди и помещает ее в стек вызовов для выполнения.
3. Этот процесс повторяется бесконечно, вот почему это называется "циклом событий".

```
console.log('Start'); // 1

setTimeout(function() {
    console.log('Timeout 1'); // 5
}, 0);

Promise.resolve().then(function() {
    console.log('Promise 1'); // 3
}).then(function() {
    console.log('Promise 2'); // 4
});

console.log('End'); // 2

```

Важно отметить, что JavaScript имеет только один основной поток выполнения. Это означает, что он может обрабатывать только одну задачу за раз. Однако благодаря асинхронному программированию и Event Loop, он может обрабатывать множество асинхронных операций одновременно, помещая их в очередь и выполняя их, когда основной стек вызовов пуст.
***
## Pinia и Vuex 
- это оба инструмента для управления состоянием в Vue.js. Они позволяют вам хранить, изменять и отслеживать состояние вашего приложения в централизованном хранилище, упрощая таким образом разделение данных между компонентами.
Vuex - это официальный плагин управления состоянием для Vue.js, который был частью экосистемы Vue с самого начала.
Pinia - это более новый инструмент управления состоянием, созданный одним из основных участников Vue.js, Эдуардом Морьяном. Он был разработан как альтернатива Vuex, и призван облегчить работу с состоянием и сделать код более понятным и меньшим по объему.

Основные отличия Pinia от Vuex:

1. **Синтаксис и структура**: Pinia предлагает более простой и прямой синтаксис по сравнению с Vuex. В Pinia нет разделения на мутации и действия, вы просто определяете функции, которые изменяют состояние вашего хранилища.
2. **Интеграция с TypeScript**: Pinia предлагает более совершенную поддержку TypeScript, что делает его хорошим выбором для проектов, которые используют TypeScript.
3. **Использование хуков хранилища**: Pinia предлагает хуки хранилища, которые можно использовать для выполнения действий при установке и удалении хранилища.
4. **Навигация по истории**: Pinia имеет встроенную поддержку отслеживания изменений состояния через панель инструментов Vue Devtools.
5. **Поддержка SSR**: Pinia также поддерживает серверный рендеринг (SSR) без необходимости в дополнительной настройке.

Важно заметить, что выбор между Vuex и Pinia в значительной степени зависит от ваших личных предпочтений и требований проекта. Несмотря на некоторые улучшения, которые предлагает Pinia, Vuex остается надежным и проверенным инструментом, который активно поддерживается и широко используется в сообществе Vue.js.
### Vuex
```
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment(state) {
      state.count++
    }
  },
  actions: {
    increment(context) {
      context.commit('increment')
    }
  },
  getters: {
    count: state => state.count
  }
})

// Использование в компоненте
export default {
  computed: {
    count() {
      return this.$store.getters.count
    }
  },
  methods: {
    increment() {
      this.$store.dispatch('increment')
    }
  }
}
```
### Pinia
```
import { createPinia } from 'pinia'

export const useStore = createPinia()

export const useCounterStore = () => {
  return {
    count: 0,
    increment() {
      this.count++
    }
  }
}

// Использование в компоненте
import { useCounterStore } from './store'

export default {
  setup() {
    const store = useCounterStore()

    return {
      count: store.count,
      increment: store.increment
    }
  }
}
```
***
## Vite и Webpack 
 - это инструменты для сборки и разработки веб-приложений, но они различаются по нескольким ключевым аспектам.
1. **Скорость сборки:** 
Vite использует преобразование кода на основе ES Modules (ESM) и предоставляет значительно более быструю перезагрузку при разработке, поскольку код обрабатывается инкрементально (только измененные файлы). С другой стороны, Webpack пересобирает весь бандл, что может занять больше времени, особенно для больших приложений.
2. **Режим разработки:** 
Webpack использует live-reload для отслеживания изменений в коде и обновления браузера, что может быть медленным для больших приложений. Vite же использует native ES Modules для сервера разработки, что делает горячую замену модулей (HMR) быстрее и эффективнее.
3. **Совместимость:** 
На момент моего знания (до сентября 2021), Webpack имеет более широкую совместимость с различными библиотеками и плагинами, поскольку он существует уже довольно долго. Vite же, будучи более новым инструментом, может не поддерживать некоторые старые плагины или библиотеки.
4. **Конфигурация:** 
Webpack сложнее в настройке и требует более подробной конфигурации. Vite стремится обеспечить минимальную конфигурацию по умолчанию, чтобы упростить процесс для разработчиков.
***
## SSR 
или Server-Side Rendering (рендеринг на стороне сервера), это метод рендеринга веб-страниц, при котором исходный HTML веб-страницы генерируется на сервере, а затем отправляется в браузер, где он отображается для пользователя.
Этот подход отличается от Client-Side Rendering (CSR, рендеринг на стороне клиента), где веб-страница первоначально загружается как "пустой" HTML-файл, а затем динамически наполняется контентом с помощью JavaScript на стороне клиента.
SSR особенно полезен для оптимизации производительности и SEO (поисковой оптимизации), так как поисковые системы лучше индексируют страницы, отрендеренные на сервере, а пользователи видят контент быстрее.
***
### **Что такое "hoisting" в JavaScript?**
Hoisting или поднятие - это механизм в JavaScript, в котором переменные и объявления функций перемещаются вверх своего текущего контекста выполнения, что позволяет их использовать до их физического расположения в коде. Однако, для переменных инициализация не поднимается.
***
### **Что такое `this` в JavaScript?**
`this` в JavaScript – это ключевое слово, которое ссылается на объект, в контексте которого вызвана функция. В глобальном контексте `this` ссылается на глобальный объект (`window` в браузерах). В контексте объекта `this` ссылается на этот объект. Однако в стрелочных функциях `this` наследуется от окружающего контекста.
***
### **Что такое прототипное наследование в JavaScript?**
Прототипное наследование в JavaScript - это механизм, в котором объекты могут наследовать свойства и методы от других объектов. Это достигается через свойство `prototype`, которое ссылается на другой объект, свойства которого могут быть "унаследованы".
***
###  **Что такое обещания (promises) в JavaScript?**
Promise в JavaScript представляет собой объект, который обозначает итог выполнения асинхронной операции. Обещания могут находиться в одном из трех состояний: "ожидание", "исполнено" или "отклонено". Promises могут быть связаны в цепочки для выполнения серии асинхронных операций.
***
### **Что такое стрелочная функция в JavaScript?**
Стрелочные функции в JavaScript - это более короткий способ объявления функций. Они не связывают собственные значения `this`, `arguments`, `super` или `new.target`, что делает их идеальными для использования внутри функций высшего порядка и методов.
***
### **Что такое асинхронность в JavaScript?**
JavaScript является однопоточным языком, что означает, что он может обрабатывать только одну операцию за раз. Однако, благодаря механизмам, таким как обратные вызовы (callback functions), промисы (Promises) и асинхронные функции (Async/Await), он может обрабатывать асинхронные операции, позволяя выполнение других операций во время ожидания ответа.
***
### **Что такое функции высшего порядка в JavaScript?**
Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов и/или возвращают функции в качестве результата. Это ключевой аспект функционального программирования, и он используется во многих встроенных методах JavaScript, таких как `.map()`, `.filter()` и `.reduce()`.
***   
### **Что такое IIFE (Immediately Invoked Function Expression) в JavaScript?**
IIFE - это функциональное выражение, которое вызывается сразу после его определения. Это используется для создания приватного скоупа, чтобы избежать засорения глобального пространства имен и случайного перезаписывания переменных.
***
