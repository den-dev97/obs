## Типы  данных:
	1. String 
	2. Number (Целочесленные, с плавающей точкой. Диапозон: от -9 007 199 254 740 991 до 9007199254740991)
		1. Infinity (Математическая бесконечность. Получить: 1/0, или задать его явно)
		2. NaN (Означает вычислительную ошибку 'string'/2)
	3. BigInt
	4. Boolean
	5. Null - typeof(null) // Object - ошибка, допущеная создателем JS
	6. Undefined
	7. Symbol
	8. Object - подтип: function 

## Методы [ ]
1. `arr.push(...items) – добавляет элементы в конец,`
2. `arr.pop() – извлекает элемент из конца,`
3. `arr.shift() – извлекает элемент из начала,`
4. `arr.unshift(...items) – добавляет элементы в начало.`
5. `arr.splice(1, 1, ...items); - начиная с индекса 1, удалить 1 элемент, вставить items`
6. `arr.slice([start], [end]) - return new arr, в который копирует все элементы с индекса start до end. arr.slice() создаёт копию []`
7. `arr.concat(arg1, arg2...) create new [], в который копирует данные из других [] и дополнительные значения.`
8. `arr.forEach(function(item, index, array) { // ... делать что-то с item }) позволяет запускать функцию для каждого элемента массива.`
9. `arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.`
10. `arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.`
11. `arr.find(function(item, index, array) { // если true - возвращается первый элемент и перебор прерывается, иначе возвращается undefined });`
12. `arr.findIndex(function(item, index, array) { // начинается поиск с начала, возвращается индекс, иначе возвращается -1 });`
13. `arr.findLastIndex(function(item, index, array) { // начинается поиск с конца, возвращается индекс, иначе возвращается -1 });`
14. `arr.filter // let results = arr.filter(function(item, index, array) { // если true -- элемент добавляется к results и перебор продолжается // возвращается [] в случае, если ничего не найдено });`
15. `arr.map // Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции. let result = arr.map(function(item, index, array) { // возвращается новое значение вместо элемента });`
16. `arr.sort() // сортирует массив на месте, меняя в нём порядок элементов.`
17. `arr.reverse() - меняет порядок элементов в arr на обратный`
18. `arr.split() - разбивает строку по заданному разделителю и возвращает массив элементов`
19. `arr.join() - склеивает массив в строку по указанному разделителю`
20. `arr.reduce() - используются для вычисления единого значения с начала [] на основе всего массива arr.reduce(function(accumulator, item, index, array) { // ... }, [initial]) let result = arr.reduce((sum, current) => sum + current, 0)`
21. `arr.reduceright() - используются для вычисления единого значения с конца [] на основе всего массива arr.reduce(function(accumulator, item, index, array) { // ... }, [initial]) let result = arr.reduce((sum, current) => sum + current, 0)`
***
# Методы объектов

1. **Создание свойств**: 
    `let obj = {}; obj.newProperty = "value";`
    
2. **Чтение свойств**: 
    `let value = obj.newProperty;`
    
3. **Изменение свойств**: 
    `obj.newProperty = "newValue";`
    
4. **Удаление свойств**: 
    `delete obj.newProperty;`
    
5. **Проверка наличия свойства**: 
    `if ("newProperty" in obj) {     // свойство существует }`
    
6. **Перебор свойств**: 
    `for (let key in obj) {     console.log(key, obj[key]); }`
    
7. **Получение списка ключей**:
    `let keys = Object.keys(obj);`
    
8. **Получение списка значений**: 
    `let values = Object.values(obj);`
    
9. **Получение списка пар ключ-значение**: 
    `let entries = Object.entries(obj);`
    
10. **Копирование объекта**: 
    `let copy = Object.assign({}, obj);`
    Поверхностная копия объекта означает создание нового объекта, который копирует только верхний уровень исходного объекта. Если исходный объект содержит вложенные объекты или массивы, то в поверхностной копии будут скопированы только ссылки на эти вложенные объекты или массивы, а не их фактические значения.
    Для создания глубокой копии объекта, где каждый вложенный объект или массив также копируется, а не просто ссылается на исходный, вы можете использовать различные методы:
• **Используя JSON:** Этот метод прост, но имеет ограничения (например, он не будет работать с функциями, `undefined`, `Symbol` или с циклическими ссылками в объектах).
 `let deepCopy = JSON.parse(JSON.stringify(original));`
• **Используя рекурсию:** Вы можете написать рекурсивную функцию, которая будет проходить по каждому свойству объекта и копировать его.
```
function deepClone(obj) {
    if (obj === null) return null;
    if (typeof obj !== 'object') return obj;

    if (Array.isArray(obj)) {
        const arrCopy = [];
        for (let i = 0; i < obj.length; i++) {
            arrCopy[i] = deepClone(obj[i]);
        }
        return arrCopy;
    }

    const objCopy = {};
    for (let key in obj) {
        objCopy[key] = deepClone(obj[key]);
    }
    return objCopy;
}

let deepCopy = deepClone(original);
```   
• **Используя библиотеки:** Существуют библиотеки, такие как Lodash, которые предоставляют функции для глубокого клонирования объектов. Например, с помощью Lodash:
```
const _ = require('lodash');
let deepCopy = _.cloneDeep(original);
```

11. **Расширение объекта**: Вы можете добавить свойства из одного объекта в другой.
    `Object.assign(obj, anotherObj);`
    
12. **Проверка прототипа**: Вы можете проверить, является ли один объект прототипом другого.
    `obj instanceof ConstructorFunction;`
    
13. **Установка прототипа**: Вы можете установить прототип для объекта.
    `Object.setPrototypeOf(obj, newPrototype);`
    
14. **Получение прототипа**: Вы можете получить прототип объекта.
    `let prototype = Object.getPrototypeOf(obj);`
***
## Различия let const и var
В JavaScript, `var`, `let` и `const` - это три способа объявления переменных, каждый из которых имеет свои особенности.
**var**:
- `var` имеет функциональную область видимости.
- Переменные, объявленные с использованием `var`, поднимаются (hoisting) к началу своей области видимости. Это означает, что переменная может быть объявлена после того, как она была использована.
- Переменные, объявленные как `var`, могут быть переопределены.
**let**:
- `let` объявляет переменную в рамках блочной области видимости. Это означает, что переменная, объявленная внутри блока кода (например, внутри цикла или условного оператора), не существует за пределами этого блока.
- Переменные, объявленные как `let`, не поднимаются к началу своей области видимости.
- Переменные, объявленные как `let`, могут быть переопределены в рамках своей области видимости.
**const**:
- `const` также объявляет переменную в рамках блочной области видимости, как и `let`.
- Переменные, объявленные как `const`, не поднимаются к началу своей области видимости.
- Переменные, объявленные как `const`, не могут быть переопределены. Это означает, что после их инициализации, вы не можете изменить их значение. Это делает `const` хорошим выбором для переменных, значение которых не должно меняться.
***
## Архитектура программного обеспечения 
- это структурный и концептуальный вид программного обеспечения, определяющий его компоненты, их функции и взаимодействие. Вот несколько типов архитектуры программного обеспечения:

1. **Многослойная архитектура:** Структура программного обеспечения разделяется на три основных слоя: представление, бизнес-логика и доступ к данным. Это обеспечивает отделение областей ответственности и упрощает тестирование.
2. **Микро сервисная архитектура:** Приложение состоит из набора независимых микро сервисов, каждый из которых выполняет определенную функцию и взаимодействует с другими через API. Это улучшает масштабируемость и отказоустойчивость, но требует сложной координации и управления сервисами.
3. **Модульная архитектура:** Приложение разделено на независимые модули или компоненты, каждый из которых отвечает за конкретную функциональность. Это упрощает разработку и поддержку, так как каждый модуль может быть разработан и тестирован независимо.
4. **Event-Driven Architecture (EDA):** Система состоит из компонентов, которые взаимодействуют друг с другом через события. Это позволяет системе быть гибкой и масштабируемой, но может усложнить проектирование и отладку системы.
5. **Serverless Architecture:** Этот тип архитектуры позволяет разработчикам создавать и запускать приложения без необходимости управлять серверами. Это упрощает развертывание и масштабирование, но может ограничить гибкость и контроль.
6. **Service-Oriented Architecture (SOA):** Этот подход подразумевает разделение функциональности приложения на независимые службы, которые взаимодействуют друг с другом через стандартизованные протоколы. Это обеспечивает высокую модульность и масштабируемость, но может усложнить координацию и производительность.
7. **Monolithic Architecture:** В этой архитектуре все компоненты приложения объединены в одном программном пакете. Это упрощает разработку и тестирование, но может затруднить масштабирование и обновление приложения.
8. **N-Tier Architecture:** Это расширение многослойной архитектуры, где каждый слой размещается на отдельном сервере или на отдельной платформе. Это улучшает безопасность и производительность, но может усложнить конфигурацию и управление.
9. **Peer-to-Peer Architecture (P2P):** В этой архитектуре все узлы являются равноправными и могут выполнять функции как клиентов, так и серверов. Это обеспечивает высокую отказоустойчивость и распределение нагрузки, но может усложнить управление и безопасность.
10. **Model-View-Controller (MVC):** Это шаблон проектирования, который разделяет приложение на три основные компонента: модель (Model), представление (View) и контроллер (Controller). Это улучшает модульность и упрощает разработку и тестирование, но требует дополнительного планирования и конфигурации.

Выбор архитектуры зависит от многих факторов, включая требования к приложению, доступные ресурсы, навыки и опыт команды разработчиков, и многое другое.
***
## Архитектурные стили приложения

#### **RESTful (Representational State Transfer - Передача репрезентативного (объективное представление) состояния)** 
- это архитектурный стиль для разработки веб-сервисов, который опирается на принципы и ограничения веб-протокола HTTP. Он описывает подход к проектированию и организации взаимодействия между клиентом и сервером.

Основные принципы RESTful-архитектуры:
1. **Ресурсы (Resources)**: В REST, данные или сервисы, которые приложение может использовать, называются ресурсами. Каждый ресурс идентифицируется с помощью уникального URL (Uniform Resource Locator), который является "адресом" ресурса.
2. **HTTP-методы (HTTP Methods)**: REST использует стандартные HTTP-методы для работы с ресурсами. Это включает в себя GET (получение данных), POST (создание новых данных), PUT (обновление существующих данных) и DELETE (удаление данных).
3. **Стандартные форматы данных**: REST API обычно используют стандартные форматы данных, такие как JSON (JavaScript Object Notation) или XML (eXtensible Markup Language) для отправки и получения данных.
4. **Stateless (Без сохранения состояния)**: Одной из ключевых особенностей REST является то, что сервер не сохраняет информацию о состоянии между различными запросами. Это означает, что каждый запрос должен содержать всю необходимую информацию для его обработки.
5. **Client-Server Architecture (Архитектура клиент-сервер)**: REST API основаны на архитектуре клиент-сервер, где клиент (обычно веб-браузер или другое приложение) отправляет запросы на сервер, который обрабатывает эти запросы и возвращает ответы обратно клиенту.
6. **Cacheable (Кешируемость)**: Ответы от сервера могут быть кешированы (или сохранены) на стороне клиента для улучшения производительности.

RESTful-сервисы организуют данные в виде ресурсов, которые могут быть идентифицированы уникальными URI. Клиенты могут выполнять операции над этими ресурсами, отправляя запросы HTTP на соответствующие URI, используя соответствующие методы (GET, POST, PUT, DELETE) и передавая данные, когда это необходимо.

В дополнение к REST, существуют и другие архитектурные стили и паттерны, которые используются при проектировании систем. Вот несколько из них:

1. **SOAP (Simple Object Access Protocol):** Этот стиль используется для обмена структурированными информационными сообщениями через веб-сервисы. SOAP может использоваться с любым протоколом передачи данных, хотя наиболее распространено его использование с HTTP.
2. **GraphQL:** Это открытый стиль API, разработанный Facebook, который позволяет клиентам определять структуру данных, которые они требуют, и объединять множественные запросы в один. Это может привести к более эффективному использованию пропускной способности по сравнению с REST.
3. **Event-Driven Architecture (EDA):** В этом стиле архитектуры, основной упор делается на производство, обнаружение и реакцию на события, которые могут происходить в приложении. Это приводит к высокой адаптивности и может быть полезно в реальном времени и асинхронных системах.
4. **Service-Oriented Architecture (SOA):** SOA предполагает разделение функциональности приложения на отдельные сервисы, каждый из которых выполняет конкретную бизнес-функцию и взаимодействует с другими сервисами через веб-сервисы.
5. **Hexagonal Architecture (also known as Ports and Adapters):** Этот стиль архитектуры направлен на создание приложений с четким разделением между внутренней логикой приложения и слоями адаптеров, которые обеспечивают связь с внешним миром (например, базами данных, веб-сервисами и т.д.).
6. **Microkernel Architecture (Plug-in Architecture):** Этот стиль архитектуры делит систему на набор ядерных компонентов и набор плагинов, которые могут быть динамически добавлены для расширения функциональности.

Эти стили и паттерны могут быть использованы в различных комбинациях и адаптированы под конкретные требования и обстоятельства проекта.

***
Проектирование архитектуры программного обеспечения — это критически важный этап в разработке, который влияет на эффективность, надежность и расширяемость системы. Вот некоторые методы и подходы, которые часто используются для проектирования архитектуры, особенно в контексте фронтенд-разработки на Vue.js и других современных фреймворках:

### Модульный подход

1. **Компонентная архитектура**: Разделение UI на независимые, повторно используемые компоненты. В Vue.js это особенно актуально, благодаря его компонентной модели.
2. **Vuex для управления состоянием**: Использование Vuex для централизованного управления состоянием приложения.

### Принципы SOLID

1. **Single Responsibility Principle (SRP)**: Каждый модуль или компонент должен иметь одну ответственность.
2. **Open/Closed Principle**: Система должна быть открыта для расширения, но закрыта для модификации.

### Архитектурные шаблоны

1. **MVC (Model-View-Controller)**: Хотя Vue.js следует шаблону MVVM, MVC все равно может быть применен для структурирования бэкенда или даже фронтенда в некоторых случаях.
2. **MVVM (Model-View-ViewModel)**: Это основной шаблон для Vue.js, который обеспечивает двустороннюю привязку данных между View и ViewModel.
3. **Clean Architecture**: Этот подход подразумевает разделение кода на слои с различными уровнями абстракции, что упрощает тестирование и поддержку.

### Другие методики

1. **TDD (Test-Driven Development)**: Разработка через тестирование может помочь сфокусироваться на требованиях к функциональности и улучшить качество кода.
2. **DDD (Domain-Driven Design)**: Этот подход полезен для сложных систем и помогает сосредоточиться на бизнес-логике.
3. **Microservices**: Для больших и сложных приложений, разбиение на микросервисы может улучшить масштабируемость и упростить разработку.

***
### MVC (Model-View-Controller)

#### Описание:
MVC — это архитектурный шаблон, который разделяет приложение на три основные логические компонента: модель, представление и контроллер. Это делается для разделения внутренних представлений информации, способов взаимодействия пользователя с ней и управления этим взаимодействием.

#### Компоненты:

1. **Model (Модель)**: Отвечает за данные и бизнес-логику. Модель не имеет прямого доступа к представлению, но может уведомлять его об изменениях через контроллер.
2. **View (Представление)**: Отображает данные, предоставляемые моделью, и отправляет команды пользовательского ввода контроллеру.
3. **Controller (Контроллер)**: Принимает ввод пользователя через представление, обрабатывает его с помощью модели и обновляет представление.

#### Применение во фронтенде:
Во фронтенд-разработке, особенно с использованием фреймворков вроде Vue.js, MVC может быть адаптирован в MVVM (Model-View-ViewModel), где ViewModel служит адаптером между Model и View.

### Clean Architecture

#### Описание:
Clean Architecture — это концепция, предложенная Робертом Мартином (Uncle Bob), которая направлена на создание системы с разделенными зависимостями. Это делается для того, чтобы систему было легче поддерживать, тестировать и расширять.

#### Слои:

1. **Entities (Сущности)**: Содержат основную бизнес-логику и правила. Они не зависят от других слоев.
2. **Use Cases**: Этот слой содержит специфическую бизнес-логику, которая описывает, что система может делать.
3. **Interface Adapters (Адаптеры интерфейса)**: Этот слой преобразует данные между Use Cases и UI/Web/DB.
4. **Frameworks and Drivers**: Это внешний слой, который содержит все фреймворки, библиотеки и другие детали, которые не относятся к бизнес-логике (например, Vue.js, Laravel, Django).

#### Применение во фронтенде:
В контексте фронтенда, Clean Architecture может быть использована для разделения логики приложения на четко определенные слои, что упрощает тестирование и поддержку.

### Что такое MVVM?

MVVM (Model-View-ViewModel) — это архитектурный паттерн проектирования, который разделяет приложение на три основные компоненты:

1. **Model (Модель)**: Отвечает за бизнес-логику и данные. Взаимодействует с базой данных и обновляет ViewModel.
2. **View (Представление)**: Отвечает за отображение данных и пользовательский интерфейс.
3. **ViewModel (Модель представления)**: Является посредником между Model и View. Обрабатывает все логические операции, необходимые для представления.

### Связь с Vue.js

Vue.js часто описывается как фреймворк, следующий паттерну MVVM. В этом контексте:

- **Model**: Данные и методы внутри компонентов Vue, которые вы определяете в `data`, `computed`, `methods`, и так далее.
- **View**: Шаблон (template) компонента, который определяет, как данные должны отображаться.
- **ViewModel**: Экземпляр Vue (Vue instance), который связывает Model и View через систему реактивности. Vue.js автоматически обновляет DOM, когда изменяются данные, и обрабатывает пользовательские взаимодействия, чтобы обновить Model.

Таким образом, Vue.js обеспечивает двустороннюю реактивную привязку данных, автоматически синхронизируя Model и View. Это делает его хорошим выбором для реализации архитектуры в стиле MVVM.



## HTTP-запрос
HTTP запрос можно осуществить различными способами:
1. Fetch API,  XMLHttpRequest (XHR), Axios, jQuery AJAX, Superagent, node-fetch, got, reqwest, Angular HttpClient, Vue Resource и т.д.
	HTTP-запрос — это сообщение, которое отправляется клиентом (обычно браузером) на сервер в процессе обмена данными по протоколу **HTTP (Hypertext Transfer Protocol)**, который является основой любого обмена данными в Интернете.
	HTTP-запросы состоят из различных частей, включая:
	1. **Метод запроса**: Это тип операции, который клиент хочет выполнить. Существует несколько методов HTTP, включая GET (запрос данных от сервера), POST (отправка данных на сервер), PUT (обновление существующих данных на сервере), DELETE (удаление данных на сервере) и другие.
	2. **URL (Uniform Resource Locator)**: URL определяет, куда направить запрос. Это может включать доменное имя сервера и путь к конкретному ресурсу на сервере.
	3. **Заголовки**: Заголовки могут содержать различные метаданные о запросе, такие как тип содержимого, кодировку, куки и другие данные.
	4. **Тело запроса**: Некоторые методы HTTP (например, POST и PUT) могут включать тело запроса, которое содержит данные, отправляемые на сервер. В запросах с методом GET тела нет.
Вот наиболее распространенные HTTP-методы и их назначение:
1. **GET**: Используется для получения данных с сервера. Запросы GET не должны изменять состояние сервера и могут содержать параметры в URL-адресе.
```
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => { console.log(data); // Получение данных с сервера })
  .catch(error => { console.error(error) });
```
2. **POST**: Используется для отправки данных на сервер для создания новых ресурсов. POST-запросы могут содержать данные в теле запроса и обычно приводят к изменению состояния сервера.
```
const newData = { name: 'John', age: 30 };

fetch('https://api.example.com/data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(newData)
})
  .then(response => response.json())
  .then(data => { console.log(data); // Создание нового ресурса на сервере })
  .catch(error => { console.error(error) });
```
3. **PUT**: Используется для отправки данных на сервер с целью полного обновления существующего ресурса. PUT-запросы содержат данные в теле запроса и перезаписывают текущую версию ресурса.
```
const updatedData = { name: 'John Doe', age: 35 };

fetch('https://api.example.com/data/1', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(updatedData)
})
  .then(response => response.json())
  .then(data => { console.log(data) // Обновление существующего ресурса на сервере })
  .catch(error => { console.error(error) });
```
4. **PATCH**: Используется для отправки данных на сервер с целью частичного обновления существующего ресурса. PATCH-запросы содержат данные в теле запроса и применяют изменения к текущей версии ресурса.
5. **DELETE**: Используется для удаления существующего ресурса на сервере.
```
fetch('https://api.example.com/data/1', {  method: 'DELETE' })
  .then(response => { console.log('Ресурс успешно удален') })
  .catch(error => { console.error(error) });
```
6. **OPTIONS**: Используется для получения информации о доступных опциях или методах, поддерживаемых сервером для определенного ресурса.
7. **HEAD**: Похож на GET-запрос, но возвращает только заголовки ответа, без фактического содержимого.
8. **TRACE**: Используется для эхо-тестирования, когда сервер возвращает входящий запрос в виде ответа, позволяя клиенту видеть, как его запросы проходят через различные системы.
9. **CONNECT**: Используется для установки соединения с сервером через прокси.
***
## Версии HTTP
### HTTP/1.1

- Один TCP-соединение для каждого запроса-ответа.
- Текстовый протокол, легко читаемый и отлаживаемый.
- Ограниченная эффективность из-за "head-of-line blocking" (задержка из-за ожидания предыдущего запроса).

- Используется в большинстве веб-приложений.
- Поддерживается всеми современными браузерами и серверами.

### HTTP/2

- Множественные запросы и ответы могут передаваться параллельно через одно TCP-соединение.
- Бинарный протокол, что улучшает производительность.
- Поддержка серверного "push", позволяющего серверу активно отправлять ресурсы клиенту.
- Улучшенная компрессия заголовков.

- Используется для оптимизации загрузки веб-страниц и API-запросов.
- Поддерживается большинством современных браузеров.

### HTTP/3
- Использует протокол QUIC вместо TCP, что уменьшает задержку.
- Улучшенная обработка потери пакетов и переключение между сетями.
- Встроенная поддержка множественных потоков и улучшенная безопасность.

- В настоящее время находится в стадии активного внедрения.
- Поддерживается некоторыми современными браузерами и веб-серверами.

### Сравнение

| Критерий          | HTTP/1.1 | HTTP/2  | HTTP/3  |
|------------------|----------|---------|---------|
| Протокол         | TCP      | TCP     | QUIC    |
| Формат           | Текст    | Бинарный| Бинарный|
| Множественные потоки | Нет    | Да      | Да      |
| Серверный "push" | Нет      | Да      | Да      |
| Задержка         | Высокая  | Средняя | Низкая  |

Это краткое сравнение HTTP/1.1, HTTP/2 и HTTP/3. Если у вас есть дополнительные вопросы или что-то неясно, не стесняйтесь спрашивать.
Использование HTTP/2 или HTTP/3 в вашем проекте зависит от нескольких факторов, включая ваш веб-сервер, обратный прокси и браузеры, которые должны поддерживать ваше приложение. Вот несколько шагов, которые вы можете предпринять для включения HTTP/2 или HTTP/3:

### HTTP/2

1. **Обновите ваш веб-сервер**: Убедитесь, что ваш веб-сервер поддерживает HTTP/2. Например, для Nginx это версия 1.9.5+.
2. **Настройте SSL**: HTTP/2 требует SSL/TLS для безопасности. Убедитесь, что у вас есть действующий SSL-сертификат.
3. **Включите HTTP/2 в конфигурации**: Для Nginx, это может выглядеть так:

    ```nginx
    server {
      listen 443 ssl http2;
      ssl_certificate /etc/nginx/ssl/nginx.crt;
      ssl_certificate_key /etc/nginx/ssl/nginx.key;
      # остальная конфигурация
    }
    ```

### HTTP/3
1. **Выберите поддерживающий HTTP/3 сервер**: Не все веб-серверы поддерживают HTTP/3. Caddy и некоторые версии Nginx это делают.
2. **Настройте QUIC и HTTP/3**: Это может быть сложнее, чем HTTP/2, и конкретные шаги зависят от вашего сервера.

    Для Nginx:

    ```nginx
    server {
      listen 443 ssl http2;
      listen [::]:443 ssl http2;
      
      # QUIC и HTTP/3.
      listen 443 udp reuseport;
      listen [::]:443 udp reuseport;
      
      ssl_protocols TLSv1.3;
      ssl_prefer_server_ciphers off;
      
      # другие настройки SSL и сервера
      ssl_certificate /etc/nginx/ssl/nginx.crt;
      ssl_certificate_key /etc/nginx/ssl/nginx.key;
      
      # Настройки QUIC и HTTP/3
      ssl_protocols TLSv1.3;
      ssl_prefer_server_ciphers off;
      
      ssl_protocols TLSv1.3;
      ssl_prefer_server_ciphers off;
    }
    ```

3. **Тестирование**: После настройки убедитесь, что все работает, как ожидалось.

### В Nuxt.js и Vue.js

Ваши фронтенд-проекты на Nuxt.js или Vue.js будут автоматически использовать HTTP/2 или HTTP/3, если сервер настроен соответствующим образом. Нет необходимости в специфических настройках на стороне клиента.

Обратите внимание, что поддержка HTTP/3 ещё не полностью стабильна и может не поддерживаться всеми браузерами или серверами.
## **Помимо HTTP есть так же:**
1. **HTTPS (HyperText Transfer Protocol Secure)**: Это просто HTTP, но с добавленным слоем безопасности SSL (Secure Sockets Layer) или TLS (Transport Layer Security), которые шифруют данные, передаваемые между клиентом и сервером.
2. **FTP (File Transfer Protocol)**: Этот протокол используется для передачи файлов между клиентом и сервером. Он поддерживает передачу больших файлов и может быть настроен для работы в активном или пассивном режиме.
3. **SMTP (Simple Mail Transfer Protocol)**: Этот протокол используется для отправки электронной почты. Обычно SMTP используется для отправки сообщений, в то время как POP3 или IMAP используются для их получения.
4. **WebSockets**: ### Что такое WebSockets?

WebSocket — это протокол, предназначенный для установления двустороннего обмена данными между клиентом и сервером по открытому соединению. Этот протокол обеспечивает более эффективное взаимодействие по сравнению с REST или AJAX, потому что после установления соединения данные могут передаваться в обоих направлениях без необходимости повторного открытия соединения.
1. **Установление соединения**: Клиент отправляет HTTP-запрос с заголовком `Upgrade: websocket` для установления WebSocket-соединения.
2. **Обмен данными**: После установления соединения сервер и клиент могут отправлять сообщения в обоих направлениях в реальном времени.
**Клиент:**
```javascript
const socket = new WebSocket('ws://example.com/socket');

socket.addEventListener('open', function(event) {
  socket.send('Hello Server!');
});

socket.addEventListener('message', function(event) {
  console.log('Received:', event.data);
});
```

**Сервер (Node.js с использованием библиотеки `ws`):**
```javascript
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws) {
  ws.on('message', function incoming(message) {
    console.log('Received:', message);
  });

  ws.send('Hello Client!');
});
```

**Преимущества:**
- Двусторонний обмен данными в реальном времени.
- Меньше накладных расходов по сравнению с HTTP.
- 
**Ограничения:**
- Не все прокси и брандмауэры поддерживают WebSockets.
- Необходим специализированный сервер для обработки WebSocket-соединений.

6. **gRPC (Google Remote Procedure Call)**: Этот протокол, разработанный Google, использует протокол HTTP/2 и поддерживает множество языков программирования. Он использует Protobuf (Protocol Buffers) для эффективной сериализации структурированных данных и поддерживает функции, такие как аутентификация, нагрузочное балансирование и отмена запросов.
7. **MQTT (Message Queuing Telemetry Transport)**: Это протокол передачи сообщений, который часто используется в системах IoT (Internet of Things) для обмена данными между устройствами с низкими требованиями к пропускной способности и энергопотреблению.
***
### Что такое Server-Sent Events (SSE)?

Server-Sent Events (SSE) — это простой и эффективный стандарт, позволяющий серверам отправлять клиентам (обычно веб-браузерам) реальные обновления через одно HTTP-соединение. SSE предназначены для односторонней коммуникации от сервера к клиенту и являются альтернативой более сложным решениям, таким как WebSockets.

1. **Инициализация**: Клиент отправляет HTTP GET-запрос на сервер с заголовком `Accept: text/event-stream`.
2. **Ответ сервера**: Сервер отвечает с заголовком `Content-Type: text/event-stream` и удерживает соединение открытым.
3. **Отправка событий**: Сервер может отправлять сообщения в любое время, используя специальный формат данных.

```javascript
const eventSource = new EventSource('/events');

eventSource.onmessage = function(event) {
  console.log('New message:', event.data);
};

eventSource.addEventListener('customEvent', function(event) {
  console.log('Custom event:', event.data);
});
```

### Пример на сервере (Node.js с Express):

```javascript
app.get('/events', (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  
  // отправить событие каждую секунду
  const intervalId = setInterval(() => {
    res.write(`data: ${new Date().toLocaleTimeString()}\n\n`);
  }, 1000);

  req.on('close', () => {
    clearInterval(intervalId);
  });
});
```

**Преимущества:**

- Простота использования и настройки.
- Поддерживается большинством современных браузеров.
- Меньше накладных расходов по сравнению с WebSockets для односторонней коммуникации.

**Ограничения:**

- Односторонняя коммуникация (только от сервера к клиенту).
- Не поддерживается в Internet Explorer.
- Может быть менее эффективным для двусторонней коммуникации по сравнению с WebSockets.

Во Vue и Nuxt вы можете использовать SSE для реализации функциональности в реальном времени, такой как уведомления или живые обновления данных. Вы можете создать соединение внутри метода или жизненного цикла компонента и слушать события от сервера.
***
## Общение между вкладками браузера 
можно наладить несколькими способами. Вот некоторые из них:

### 1. LocalStorage и событие `storage`

Вы можете использовать `localStorage` для сохранения данных, которые должны быть доступны на всех вкладках. Когда данные в `localStorage` изменяются, срабатывает событие `storage` на других вкладках, и вы можете считать новые данные.

```javascript
// Слушать событие storage
window.addEventListener('storage', function(event) {
  if (event.key === 'my-key') {
    console.log('Data changed:', event.newValue);
  }
});

// Изменить данные (на другой вкладке или в другом окне)
localStorage.setItem('my-key', 'new value');
```

### 2. Broadcast Channel API

Этот API позволяет отправлять сообщения между различными контекстами выполнения (например, между вкладками, фреймами или работниками).

```javascript
// Создать канал
const channel = new BroadcastChannel('my_channel');

// Отправить сообщение
channel.postMessage('Hello, other tabs!');

// Получить сообщение
channel.onmessage = function(event) {
  console.log('Received:', event.data);
};
```

### 3. SharedWorker

Shared Worker — это тип веб-воркера, который может быть доступен из нескольких скриптов или вкладок. Вы можете использовать его для обмена сообщениями между вкладками.

```javascript
// main.js
const worker = new SharedWorker('worker.js');

worker.port.addEventListener('message', function(event) {
  console.log('Received from worker:', event.data);
});

worker.port.start();

// worker.js
self.addEventListener('connect', function(event) {
  const port = event.ports[0];

  port.addEventListener('message', function(event) {
    port.postMessage('Received: ' + event.data);
  });

  port.start();
});
```

### 4. Window.postMessage

Этот метод позволяет отправлять сообщения между окнами или фреймами, даже если они имеют разные источники.

```javascript
// Отправить сообщение
otherWindow.postMessage('Hello, other window!', 'http://example.com');

// Получить сообщение
window.addEventListener('message', function(event) {
  if (event.origin === 'http://example.com') {
    console.log('Received:', event.data);
  }
});
```

***
## Какие бывают Workers
В современной браузерной разработке часто используются следующие типы воркеров:

### 1. Web Workers

**Основные характеристики:**

- Работают в фоновом потоке, параллельно основному потоку.
- Не имеют доступа к DOM и некоторым Web API.
- Идеальны для выполнения тяжелых вычислений и обработки данных.

**Пример:**

```javascript
// main.js
const worker = new Worker('worker.js');

worker.postMessage('Hello, worker!');
worker.onmessage = (event) => {
  console.log('Received:', event.data);
};

// worker.js
self.onmessage = (event) => {
  self.postMessage('Received: ' + event.data);
};
```

### 2. Service Workers

**Основные характеристики:**

- Используются для кэширования ресурсов и создания офлайн-приложений.
- Могут перехватывать сетевые запросы и управлять ими.
- Работают в фоновом режиме и могут реагировать на события, такие как `push` и `sync`.

**Пример:**

```javascript
// sw.js
self.addEventListener('fetch', (event) => {
  event.respondWith(fetch(event.request));
});

// main.js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}
```

### 3. Shared Workers

**Основные характеристики:**

- Работают в фоновом потоке и могут быть доступны из нескольких контекстов (вкладок, фреймов).
- Используются для общения между вкладками и координации работы.

**Пример:**

```javascript
// main.js
const worker = new SharedWorker('shared-worker.js');

worker.port.postMessage('Hello, shared worker!');
worker.port.onmessage = (event) => {
  console.log('Received:', event.data);
};

// shared-worker.js
self.addEventListener('connect', (event) => {
  const port = event.ports[0];
  port.postMessage('Connected to shared worker');
});
```

### 4. Worklets

**Основные характеристики:**

- Используются для расширения возможностей CSS и обработки аудио.
- Например, `CSS Paint API` и `Audio Worklet`.

**Пример:**

```javascript
// main.js
CSS.paintWorklet.addModule('paint-worklet.js');

// paint-worklet.js
registerPaint('circle', class {
  paint(ctx, geom, properties) {
    // рисование круга
  }
});
```
***
## Трассировка запросов (Request Tracing) 
— это метод мониторинга и анализа взаимодействия между различными компонентами в распределенных системах. Это особенно полезно в микросервисных архитектурах, где один внешний запрос может инициировать несколько внутренних запросов между сервисами.

### Как это работает?

1. **Идентификация запроса**: Каждый входящий запрос получает уникальный идентификатор (Trace ID), который сохраняется на протяжении всего жизненного цикла запроса.

2. **Пропагация идентификатора**: Этот идентификатор передается от одного сервиса к другому в заголовках HTTP-запросов.

3. **Сбор данных**: В каждом сервисе собираются метаданные о запросе, такие как время начала и завершения обработки, статус ответа и другие.

4. **Агрегация данных**: Собранные данные отправляются в централизованную систему для анализа и мониторинга, такую как Jaeger или Zipkin.

### Зачем это нужно?

- **Отладка**: Упрощает процесс нахождения проблем в распределенных системах.
- **Мониторинг производительности**: Позволяет анализировать, какие части системы являются узкими местами.
- **Безопасность**: Помогает отслеживать необычные или подозрительные действия в системе.

### Применение во Vue и Nuxt
В контексте фронтенд-разработки на Vue.js или Nuxt.js трассировка запросов обычно не реализуется на уровне фреймворка, но вы можете использовать HTTP-клиенты, которые поддерживают трассировку запросов, например, Axios. Вы можете добавить трассировочные идентификаторы в заголовки HTTP-запросов для интеграции с бэкенд-системой трассировки.

***
## **JSON (JavaScript Object Notation)** и **XML (eXtensible Markup Language)** 
	- это два распространенных формата данных, используемых для хранения и передачи данных в структурированном виде. Оба эти формата поддерживают структуры данных, такие как массивы и объекты, и могут быть легко прочитаны людьми.

1. **JSON:** Этот формат основан Дугласом Крокфордом (книга  «Как устроен JavaScript») на синтаксисе JavaScript и представляет собой текстовый формат, который легко читается и записывается. JSON стал очень популярным для обмена данными между браузером и сервером, поскольку его легко использовать в JavaScript и других языках программирования. Пример данных в формате JSON:
```
{
    "name": "John",
    "age": 30,
    "city": "New York"
}
```
2. **XML:** Это более старый и более гибкий формат, чем JSON. Он позволяет создавать собственные теги и поддерживает атрибуты, пространства имен и схемы для валидации данных. Однако XML более громоздкий по сравнению с JSON и требует больше текста для представления тех же данных. Пример данных в формате XML:
```
<person>
    <name>John</name>
    <age>30</age>
    <city>New York</city>
</person>
```
Оба этих формата широко используются в различных областях, включая веб-разработку, конфигурационные файлы и межсерверные передачи данных. Однако JSON стал более популярным в современной веб-разработке, особенно в RESTful API, благодаря своей простоте и совместимости с JavaScript.
***
## **Что такое замыкание (closure) в JavaScript?**
Замыкание в JavaScript - это особенность, которая позволяет функции сохранять информацию о переменных, которые были доступны в момент её создания. Это означает, что функция может использовать эти переменные, даже если они уже не существуют в области видимости.
```
function outerFunction() {
  let counter = 0;
  return function () {
    counter++
    console.log(counter);
  }
}
let closureExample = outerFunction();
closureExample(); // 1 closureExample(); // 2

function multiply(a) {
  return function(b) {
    return a * b
  }
}
const multiplyByTwo = multiply(2) console.log(multiplyByTwo(2)) // 4
const multiplyByTree = multiply(3) console.log(multiplyByTree(3)) // 9

```
Замыкания полезны во многих случаях, например, при создании приватных переменных и функций, при реализации модульного паттерна или при работе с асинхронным кодом, чтобы сохранить состояние между вызовами функций.
***
## **Что такое Map и Set**
Данные в Map хранятся в виде Хэш таблицы, в результате чего доступ к ним осуществляется быстрее, чем если бы данные были бы в объекте.
`Map` и `Set` являются двумя встроенными коллекциями в JavaScript, которые предоставляют удобные способы хранения и организации данных.

#### `Map` 
представляет собой коллекцию пар "ключ-значение", как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа. Особенности `Map`:

- Гарантирует уникальность ключей. Если попытаться добавить в `Map` значение с уже существующим ключом, старое значение будет заменено новым.
- Поддерживает итерацию по парам "ключ-значение" с помощью метода `forEach` или оператора `for...of`.
- Можно использовать любые типы данных в качестве ключей.
- Предоставляет методы для добавления, удаления и обновления пар "ключ-значение", а также для получения размера `Map` и проверки наличия определенного ключа.

Методы и свойства:
- [`new Map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Map) – создаёт коллекцию.
- [`map.set(key, value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set) – записывает по ключу `key` значение `value`.
- [`map.get(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get) – возвращает значение по ключу или `undefined`, если ключ `key` отсутствует.
- [`map.has(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has) – возвращает `true`, если ключ `key` присутствует в коллекции, иначе `false`.
- [`map.delete(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete) – удаляет элемент (пару «ключ/значение») по ключу `key`.
- [`map.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear) – очищает коллекцию от всех элементов.
- [`map.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size) – возвращает текущее количество элементов.

Пример использования `Map`:
```
const map = new Map();

map.set("name", "John");
map.set("age", 30);

console.log(map.get("name")); // Выводит "John"
console.log(map.size); // Выводит 2

map.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

map.delete("age");
console.log(map.has("age")); // Выводит false
```

## [Перебор Map](https://learn.javascript.ru/map-set#perebor-map)
Для перебора коллекции `Map` есть 3 метода:
- [`map.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys) – возвращает итерируемый объект по ключам,
- [`map.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values) – возвращает итерируемый объект по значениям,
- [`map.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries) – возвращает итерируемый объект по парам вида `[ключ, значение]`, этот вариант используется по умолчанию в `for..of`.
```
let recipeMap = new Map([ 
	["огурец", 500], 
	["помидор", 350], 
	["лук", 50] 
]);
// перебор по ключам (овощи) 
for (let vegetable of recipeMap.keys()) { 
	alert(vegetable); // огурец, помидор, лук 
} 
// перебор по значениям (числа) 
for (let amount of recipeMap.values()) { 
	alert(amount); // 500, 350, 50 
} 
// перебор по элементам в формате [ключ, значение] 
for (let entry of recipeMap) { 
	// то же самое, что и recipeMap.entries() 
	alert(entry); // огурец,500 (и так далее) 
}
```
Мы можем создать `Map` из обычного объекта следующим образом:
```
let obj = { name: "John", age: 30 }; 
let map = new Map(Object.entries(obj));
alert( map.get('name') ); // John
```
И можем сделать наоборот - создать объект из Map
```
let map = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);
let obj = Object.fromEntries(map.entries()); 
// obj = { огурец: 500, помидор: 350, лук: 50 }
```
#### `Set` 
представляет собой коллекцию уникальных значений любого типа данных. Основные особенности `Set`:

- Хранит только уникальные значения. При попытке добавить в `Set` уже существующее значение, оно будет проигнорировано.
- Поддерживает итерацию по значениям с помощью метода `forEach` или оператора `for...of`.
- Можно использовать любые типы данных в качестве значений.

### Основные методы:
- [`new Set(iterable)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set) – создаёт `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый `Set`.
- [`set.add(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
- [`set.delete(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete) – удаляет значение, возвращает `true`, если `value` было в множестве на момент вызова, иначе `false`.
- [`set.has(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has) – возвращает `true`, если значение присутствует в множестве, иначе `false`.
- [`set.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/clear) – удаляет все имеющиеся значения.
- [`set.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size) – возвращает количество элементов в множестве.

Пример использования `Set`:
```
const set = new Set();

set.add("apple");
set.add("banana");
set.add("apple"); // Дубликат "apple" будет проигнорирован

console.log(set.size); // Выводит 2

set.forEach(value => {
  console.log(value);
});

set.delete("banana");
console.log(set.has("banana")); // Выводит false
```
Альтернативой множеству `Set` может выступать массив для хранения гостей и дополнительный код для проверки уже имеющегося элемента с помощью [arr.find](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find). Но в этом случае будет хуже производительность, потому что `arr.find` проходит весь массив для проверки наличия элемента. Множество `Set` лучше оптимизировано для добавлений, оно автоматически проверяет на уникальность.
Вот основные отличия между `Map` и `Set`:

1. Уникальность элементов: `Map` сохраняет уникальные пары "ключ-значение", тогда как `Set` хранит только уникальные значения.
2. Тип данных ключа: В `Map` ключами могут быть любые типы данных, включая примитивы и объекты. В `Set` значениями могут быть любые типы данных, но ключи и значения идентичны.
3. Итерация: `Map` предоставляет методы для итерации по парам "ключ-значение" с помощью `forEach` или `for...of`, в то время как `Set` позволяет итерироваться только по значениям.
4. Размер: `Map` имеет свойство `size`, которое возвращает количество пар "ключ-значение" в коллекции. У `Set` также есть свойство `size`, которое возвращает количество уникальных значений в коллекции.
5. Удаление элементов: В `Map` элементы можно удалить с помощью метода `delete`, передавая ключ в качестве аргумента. В `Set` элементы также удаляются с помощью метода `delete`, но в качестве аргумента передается значение.
6. Порядок элементов: `Map` сохраняет порядок добавления пар "ключ-значение". Это означает, что при итерации элементы будут возвращаться в том же порядке, в котором они были добавлены. В `Set` порядок элементов определяется порядком их добавления, но он не гарантирован и может быть изменен внутренней реализацией JavaScript.

Оба `Map` и `Set` предоставляют эффективные методы для добавления, удаления и поиска элементов. Выбор между `Map` и `Set` зависит от специфических потребностей вашего приложения и типа данных, которые вы хотите хранить. Если вам нужно хранить пары "ключ-значение" или требуется быстрый поиск по ключу, то `Map` будет предпочтительнее. Если вам нужно хранить только уникальные значения и вам не важен порядок, то `Set` будет более подходящим выбором.
Использование `Map` и `Set` позволяет эффективно хранить и манипулировать данными, обеспечивая быстрый доступ и уникальность значений или пар "ключ-значение". Выбор между `Map` и `Set` зависит от конкретных потребностей и требований вашего приложения.
***
## `WeakMap` и `WeakSet` 
— это специальные виды коллекций в JavaScript, которые позволяют создавать "слабые" ссылки на объекты. Это означает, что объекты могут быть автоматически удаляемы сборщиком мусора, когда на них нет других ссылок.

`WeakMap`: Это вариант `Map`, где ключи должны быть объектами, и если нет других ссылок на ключ, то он будет удален сборщиком мусора, а соответствующая пара ключ-значение будет удалена из `WeakMap`. Это делает `WeakMap` полезным в ситуациях, когда вам нужно связать дополнительные данные с объектом, но не хотите, чтобы эти данные предотвращали удаление объекта, когда он больше не нужен в программе.
```
let weakMap = new WeakMap();

let obj = {};

// добавляем в weakMap
weakMap.set(obj, "data");

// объект доступен через weakMap
console.log(weakMap.get(obj));  // "data"

// когда объект больше не доступен,
// он будет удален сборщиком мусора вместе с его ассоциированными данными
obj = null;
```

`WeakSet`: Это вариант `Set`, где все значения должны быть объектами, и если нет других ссылок на объект, он может быть автоматически удален сборщиком мусора. Это полезно, когда вам нужно знать, принадлежит ли объект набору, но вы не хотите, чтобы набор предотвращал удаление объекта, когда он больше не нужен.
```
let weakSet = new WeakSet();

let obj = {};

// добавляем объект в weakSet
weakSet.add(obj);

// объект присутствует в weakSet
console.log(weakSet.has(obj));  // true

// когда объект больше не доступен,
// он будет удален сборщиком мусора и исключен из weakSet
obj = null;
```
Однако, есть одно ограничение: в отличие от `Map` и `Set`, у `WeakMap` и `WeakSet` нет методов и свойств для получения размера коллекции или для итерации по элементам. Это связано с тем, как они реализованы в движке JavaScript.
* * *
## Event Loop 
- это концепция, лежащая в основе асинхронного программирования, которая позволяет JavaScript выполнять неблокирующие операции, несмотря на то, что сам язык является однопоточным.
В общем виде, Event Loop, или цикл событий, следует следующим этапам:

1. **Call Stack (Стек вызовов)**: Это место, где выполняется ваш JavaScript код. Когда функция вызывается, она помещается на вершину стека вызовов. Когда функция завершена, она удаляется из стека.
2. **Wep Apis**: Это структура данных, которая представляет большую область памяти, где осуществляется выделение памяти для объектов JavaScript.
3. **Callback Queue (Очередь обратного вызова)**: Это список задач, которые ожидают выполнения. Когда асинхронная функция завершает свою работу (например, Ajax-запрос, таймер и т.д.), она добавляет новую задачу в очередь.

Сам Event Loop делает следующее:

1. Проверяет, есть ли в стеке вызовов какие-либо функции для выполнения. Если есть, он запускает их одну за другой, пока стек не опустеет.
2. Когда стек пуст, он смотрит на очередь задач. Если в очереди есть задачи, Event Loop берет первую задачу из очереди и помещает ее в стек вызовов для выполнения.
3. Этот процесс повторяется бесконечно, вот почему это называется "циклом событий".

```
console.log('Start'); // 1

setTimeout(function() {
    console.log('Timeout 1'); // 5
}, 0);

Promise.resolve().then(function() {
    console.log('Promise 1'); // 3
}).then(function() {
    console.log('Promise 2'); // 4
});

console.log('End'); // 2

```

### Микро-таски

Микро-таски — это задачи, которые выполняются сразу после текущего события в Event Loop, но перед перерисовкой DOM или выполнением следующего макро-таска. Примеры:

1. **Promise.then()**: Коллбеки, переданные в `Promise.then()`, добавляются в очередь микро-таск.
   ```javascript
   Promise.resolve().then(() => console.log("This is a micro-task"));
   ```
2. **queueMicrotask()**: Явное добавление микро-таска.
   ```javascript
   queueMicrotask(() => console.log("Another micro-task"));
   ```
3. **MutationObserver**: Используется для отслеживания изменений в DOM и выполняет коллбеки как микро-таски.
   ```javascript
   const observer = new MutationObserver(() => {
     console.log("DOM mutated");
   });
   ```

### Макро-таски

Макро-таски — это задачи, которые добавляются в очередь макро-таск и выполняются одна за другой. Примеры:

1. **setTimeout() и setInterval()**: Эти функции добавляют коллбеки в очередь макро-таск.
   ```javascript
   setTimeout(() => console.log("This is a macro-task"), 0);
   ```
2. **I/O операции**: Например, чтение файла в Node.js.
   ```javascript
   const fs = require('fs');
   fs.readFile('/path/to/file', (err, data) => {
     console.log("File read");
   });
   ```
3. **UI рендеринг**: Обновление пользовательского интерфейса также является макро-таской.
4. **Запросы AJAX**: Они также добавляются в очередь макро-таск.

В Event Loop, макро-таски обычно имеют более высокий приоритет по сравнению с микро-тасками, но микро-таски всегда выполняются перед следующим макро-таском или перерисовкой DOM.

Для дополнительного понимания, вы можете ознакомиться с [этой статьей](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) от Jake Archibald.
***
## `MutationObserver` 
— это встроенный объект в JavaScript, который позволяет наблюдать за изменениями в DOM-дереве. Это может быть полезно в различных сценариях, таких как отслеживание изменений в элементах для реализации кастомной логики, реакции на добавление или удаление элементов и так далее.

### Как это работает
Вы создаете экземпляр `MutationObserver` и передаете ему функцию обратного вызова, которая будет вызвана при каждом изменении DOM, соответствующем заданным параметрам. Затем вы указываете, какие элементы и какие именно изменения следует наблюдать.

### Пример
Допустим, у вас есть элемент с `id="myElement"`, и вы хотите отслеживать любые изменения его дочерних элементов.

```javascript
// Функция обратного вызова, которая будет выполнена при изменении
function callback(mutationsList, observer) {
  for (const mutation of mutationsList) {
    if (mutation.type === 'childList') {
      console.log('A child node has been added or removed.');
    }
  }
}

// Создание экземпляра наблюдателя с передачей функции обратного вызова
const observer = new MutationObserver(callback);

// Настройка наблюдателя: что и где следует наблюдать
const targetNode = document.getElementById('myElement');
const config = { attributes: true, childList: true, subtree: true };

// Начало процесса наблюдения
observer.observe(targetNode, config);

// Позже можно остановить наблюдение
// observer.disconnect();
```

В этом примере `MutationObserver` будет отслеживать добавление или удаление дочерних элементов в элементе с `id="myElement"`. Как только это произойдет, функция `callback` будет вызвана, и вы сможете выполнить нужные действия.

### Применение в реальной жизни

`MutationObserver` часто используется в одностраничных приложениях для отслеживания изменений DOM, которые могут быть вызваны динамической подгрузкой контента или пользовательскими взаимодействиями. Это может быть полезно для аналитики, ленивой загрузки изображений, реализации кастомных UI-эффектов и многого другого.

***
## AJAX
стоит за асинхронным JavaScript и XML (Asynchronous JavaScript And XML). Это набор методов разработки веб-приложений, позволяющих веб-страницам быстро обмениваться данными с веб-сервером без полной перезагрузки страницы. Это позволяет делать веб-приложения более быстрыми и отзывчивыми.

Основные особенности AJAX включают:

- Асинхронность: AJAX позволяет отправлять и получать данные в фоновом режиме (асинхронно) без влияния на отображение и поведение существующей страницы.
- Использование JavaScript и XMLHttpRequest: AJAX использует объект XMLHttpRequest для обмена данными с веб-сервером. JavaScript используется для выполнения AJAX-запроса и обработки ответа от сервера.
- Формат данных: хотя в названии AJAX упоминается XML, данные могут передаваться в любом формате, включая текст, HTML, XML, JSON и др.

Пример простого AJAX-запроса с использованием встроенного в браузеры объекта `XMLHttpRequest` может выглядеть следующим образом:
```
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4 && xhr.status == 200)
    console.log(xhr.responseText);
};
xhr.send();
```

***
### **Что такое "hoisting" в JavaScript?**
Hoisting — это механизм в JavaScript, в котором переменные и объявления функций "всплывают" вверх своей области видимости перед тем, как код будет выполнен. Иными словами, переменная или функция доступна для использования до того момента, как она физически появится в коде. Но нужно понимать, что hoisting влияет только на объявления, а не на инициализацию.
### Переменные
Объявления переменных с использованием `var` всплывают, но инициализируются `undefined`:
```
console.log(a); // undefined
var a = 5;
console.log(a); // 5
```
В случае с `let` и `const`, hoisting тоже происходит, но переменная находится в "temporal dead zone" (временной мёртвой зоне) и к ней нельзя обратиться до её объявления:
```
console.log(b); // ReferenceError
let b = 10;
console.log(b); // 10
```
### Функции
Объявления функций также подвергаются hoisting и могут быть вызваны до того, как они определены в коде:
```
foo(); // "Hello"
function foo() {
  console.log("Hello");
}
```
Важно отметить, что функциональные выражения и стрелочные функции не всплывают:
```
bar(); // TypeError: bar is not a function
var bar = function() {
  console.log("World");
};
```
***
## Всплытие (event bubbling)
Всплытие (или "event bubbling") — это механизм в DOM, при котором события, произошедшие на вложенных элементах, "всплывают" к родительским элементам. Это полезно в реальных задачах по нескольким причинам:

### Делегирование событий

Вы можете назначить обработчик события на родительский элемент и, благодаря всплытию, обрабатывать события, происходящие на вложенных элементах.

**Пример:**

```html
<ul id="itemList">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

```javascript
document.getElementById('itemList').addEventListener('click', function(event) {
  alert(`You clicked on ${event.target.textContent}`);
});
```

Благодаря делегированию событий, вам не нужно назначать обработчик на каждый вложенный элемент. Это улучшает производительность и упрощает управление кодом.

Если элементы динамически добавляются в DOM (например, в SPA на Vue или Nuxt), делегирование событий позволяет автоматически "подписать" их на уже существующие обработчики событий.

Всплытие позволяет вам модифицировать свойства события или даже остановить его всплытие (`event.stopPropagation()`), если это необходимо.

Во Vue вы можете использовать модификатор `.stop` для предотвращения всплытия:

```vue
<template>
  <div @click="parentClick">
    <button @click.stop="buttonClick">Click Me</button>
  </div>
</template>

<script>
export default {
  methods: {
    parentClick() {
      console.log('Parent Div Clicked');
    },
    buttonClick() {
      console.log('Button Clicked');
    },
  },
};
</script>
```

В этом примере, при клике на кнопку, событие не будет всплывать к родительскому `div`, и будет вызван только метод `buttonClick`.

### Дополнительные ресурсы
Это краткое описание применения механизма всплытия в реальных задачах. Если у вас есть дополнительные вопросы или что-то неясно, не стесняйтесь спрашивать.

	event.stopImmediatePropagation()
Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.
То есть, `event.stopPropagation()` препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.
Для того, чтобы полностью остановить обработку, существует метод `event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.
***
### **Что такое `this` в JavaScript?**
В JavaScript `this` - это специальное ключевое слово, которое автоматически устанавливается в каждом контексте исполнения и указывает на "владельца" или "субъект" текущего исполнения. Стоит отметить, что значение `this` определяется тем, как вызывается функция, а не тем, где функция объявлена. Значение `this` может быть разным в зависимости от контекста:

1. **В глобальном контексте или внутри функции (не метода объекта или класса):** `this` ссылается на глобальный объект. В браузере это будет `window`, а в Node.js - `global`.
```
console.log(this); // Выведет `window` в браузере или `global` в Node.js

function myFunction() {
  console.log(this);
}
myFunction(); // Также выведет `window` в браузере или `global` в Node.js
```
**Внутри метода объекта:** `this` ссылается на объект, которому принадлежит метод.
```
const myObject = {
  myMethod() {
    console.log(this);
  }
};
myObject.myMethod(); // Выведет `myObject`
```
**Внутри конструктора:** `this` ссылается на новый объект, который создается при вызове конструктора.
```
function MyConstructor() {
  this.myProperty = 'Hello, world!';
  console.log(this);
}
new MyConstructor(); // Выведет новый объект, например, `{ myProperty: 'Hello, world!' }`
```
**Внутри обработчика событий:** `this` обычно ссылается на элемент, на котором произошло событие.
```
button.addEventListener('click', function() {
  console.log(this); // Выведет элемент `button`
});
```
**Внутри функций стрелочного типа:** `this` не устанавливается и наследуется от родительского контекста.
```
const myObject = {
  myMethod() {
    const arrowFunction = () => {
      console.log(this);
    };
    arrowFunction();
  }
};
myObject.myMethod(); // Выведет `myObject`
```
Значение `this` также можно явно задать с помощью методов `call`, `apply` или `bind`, **КРОМЕ** стрелочных функций.
***
## `call`, `apply` и `bind`
являются встроенными методами в JavaScript, которые позволяют прямо управлять контекстом (`this`) функции. Давайте рассмотрим каждый из них:

1. **call:** Метод `call` позволяет вызвать функцию, явно устанавливая `this` в качестве первого аргумента, а затем передавая остальные аргументы, если они есть, в функцию.
```
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'Alice' };
greet.call(person, 'Hello', '!'); // Выведет "Hello, Alice!"
```
**apply:** Метод `apply` похож на `call`, но принимает аргументы в виде массива или массивоподобного объекта, а не в виде отдельных параметров.
```
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'Alice' };
greet.apply(person, ['Hello', '!']); // Выведет "Hello, Alice!"
```
**bind:** Метод `bind` создает новую функцию, которая, когда вызывается, устанавливает `this` в предоставленное значение и предоставляет последующие аргументы вместе с аргументами, переданными при связывании.
```
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: 'Alice' };
const boundGreet = greet.bind(person, 'Hello');
boundGreet('!'); // Выведет "Hello, Alice!"
```
В каждом из этих методов, первый аргумент - это значение, которое мы хотим установить для `this`, и это обычно объект. Остальные аргументы - это параметры, которые мы хотим передать в функцию.
***
## Прототипы
Прототипное наследование в JavaScript - это такой способ передачи свойств и функций от одного объекта к другому. Все дело в том, что в JavaScript объекты могут иметь ссылки на другие объекты, которые называются "прототипами". Если у объекта отсутствует какое-то свойство или метод, JavaScript посмотрит в его прототипе, чтобы найти это свойство или метод. И если он там есть, объект получит доступ к нему. Это называется "наследованием" свойств и методов прототипа.

```
let animal = {
  eats: true,
  walk() {
    console.log("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal // наследуется от animal 
};

rabbit.walk(); // выводит "Animal walk"
console.log(rabbit.eats); // выводит true
```
Некоторые важные моменты:

1. **Цепочки прототипов:** JavaScript может искать свойства и методы далеко вглубь цепочки прототипов, если они отсутствуют в текущем объекте.
2. **Делегирование:** JavaScript не копирует свойства и методы из прототипа в объект, а просто использует их по мере необходимости. Это значит, что если вы что-то измените в прототипе, эти изменения отразятся на всех объектах, которые его используют.
3. **Прототипы и конструкторы:** Когда вы создаете объекты с помощью конструктора (т.е. функции, которая создает объект), у этой функции есть свойство `prototype`, которое используется как прототип для всех создаваемых объектов.

***
###  **Что такое обещания (promises) в JavaScript?**
Обещание (Promise) в JavaScript представляет собой объект, который связан с некоторым асинхронным операцией. Он возвращает значение этой операции в будущем, либо успешное, либо ошибку, если операция не удалась. Обещания могут находиться в одном из следующих состояний:

1. **Pending (ожидание):** Начальное состояние Обещания, которое еще не завершило свое выполнение.
2. **Fulfilled (выполнено):** Обещание успешно завершило свою операцию.
3. **Rejected (отклонено):** Операция, связанная с Обещанием, не удалась.
Обещания обычно используются для работы с асинхронными операциями, такими как работа с сетью, чтение файлов и т.д. Они обеспечивают более удобный и управляемый способ обработки асинхронности, по сравнению с традиционными обратными вызовами (callbacks).
Вот пример Обещания, которое выполняет асинхронную операцию:
```
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Promise fulfilled');
  }, 1000);
});

promise
  .then(result => console.log(result))  // Выполняется при успешном завершении Обещания
  .catch(error => console.error(error));  // Выполняется, если в Обещании произошла ошибка
  .finally(console.info('All is done!'));
```
Метод `then` принимает функцию, которая будет вызвана, когда Обещание выполнится успешно, а метод `catch` принимает функцию, которая будет вызвана, если Обещание будет отклонено. Оба метода возвращают новые Обещания, что позволяет строить цепочки из обещаний. И в самом конце `finally()` выполнится в любом случае, вне зависимости от того выполнится промис или нет

Кроме того, есть и другие вспомогательные методы, такие как `Promise.all` и `Promise.race`, которые позволяют работать с несколькими Обещаниями одновременно.

- `Promise.all` принимает массив Обещаний и возвращает новое Обещание, которое выполняется, когда все Обещания в массиве выполнены (или отклонено, как только любое из них отклонено).
- `Promise.race` принимает массив Обещаний и возвращает новое Обещание, которое выполняется или отклоняется, как только любое из Обещаний в массиве выполняется или отклоняется.

***
### **Что такое стрелочная функция в JavaScript?**
Стрелочные функции в JavaScript - это более короткий способ объявления функций. Они не связывают собственные значения `this`, `arguments`, `super` или `new.target`, что делает их идеальными для использования внутри функций высшего порядка и методов.
***
### **Что такое асинхронность в JavaScript?**
JavaScript является однопоточным языком, что означает, что он может обрабатывать только одну операцию за раз. Однако, благодаря механизмам, таким как обратные вызовы (callback functions), промисы (Promises) и асинхронные функции (Async/Await), он может обрабатывать асинхронные операции, позволяя выполнение других операций во время ожидания ответа.
***
### **Что такое функции высшего порядка в JavaScript?**
Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов и/или возвращают функции в качестве результата. Это ключевой аспект функционального программирования, и он используется во многих встроенных методах JavaScript, таких как `.map()`, `.filter()` и `.reduce()`.
***   
### **Что такое IIFE (Immediately Invoked Function Expression) в JavaScript?**
IIFE - это функциональное выражение, которое вызывается сразу после его определения. Это используется для создания приватного скоупа, чтобы избежать засорения глобального пространства имен и случайного перезаписывания переменных.
***
### CORS
CORS, или Cross-Origin Resource Sharing (совместное использование ресурсов между разными источниками), - это механизм, который позволяет многим ресурсам (например, шрифтам, JavaScript, изображениям и т.д.) на веб-странице быть запрошенными с другого домена, отличного от домена, с которого исходит первоначальный запрос.

До появления CORS веб-страницы могли получать доступ только к ресурсам своего собственного домена. Это ограничение было введено для безопасности пользователей и предотвращения возможных злоупотреблений. Однако, по мере развития интернета, стало ясно, что в некоторых случаях доступ к ресурсам с других сайтов может быть полезен и даже необходим.

Обход CORS (Cross-Origin Resource Sharing) может потребоваться при разработке frontend-приложений, которые взаимодействуют с серверами, не поддерживающими кросс-доменные запросы. Важно отметить, что обход CORS — это часто временное решение для разработки и тестирования, и это может представлять опасности для безопасности в продакшн-окружении.

### Решения на стороне клиента:
1. **Разработка с использованием прокси-сервера**: Некоторые среды разработки, такие как Webpack или Vite, предлагают возможность проксирования API-запросов, чтобы избежать проблем с CORS.
    Для Vite в `vite.config.js`:
```
export default {
  server: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
}
```
2. **CORS Anywhere**: Такие сервисы как CORS Anywhere могут помочь в обходе CORS-ограничений, но они должны использоваться только для тестирования.
```
fetch('https://cors-anywhere.herokuapp.com/http://example.com')
```
### Решения на стороне сервера:

1. **Установка CORS-заголовков**: Если у вас есть доступ к серверному коду, вы можете добавить CORS-заголовки в ответ сервера.
    Для Node.js и Express:
```
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header(
    "Access-Control-Allow-Headers",
    "Origin, X-Requested-With, Content-Type, Accept"
  );
  next();
});
```
2. **Использование Middleware**: В Express можно использовать пакеты, такие как `cors`, для упрощения управления CORS.
```
const cors = require('cors');
app.use(cors());
```
3. **Разрешение только определённых источников**: Чтобы усилить безопасность, можно указать конкретные домены, которым разрешены кросс-доменные запросы.
```
app.use(cors({
  origin: 'http://your-app-domain.com'
}));
```
**Примечание**: Изменение настроек сервера для поддержки CORS — предпочтительный и безопасный способ решения этой проблемы. Если сервер, к которому вы обращаетесь, не принадлежит вам, лучше всего связаться с его администраторами для решения вопроса настройки CORS.
***
## Оптимизация производительности веб-приложений 
— это широкая тема, и существует множество методов и подходов для её улучшения. Вот некоторые из них:

### Общие методы:
1. **Минификация и сжатие ресурсов**: Сжимайте CSS, JavaScript и HTML файлы для уменьшения времени загрузки.
2. **Кеширование**: Используйте кеширование на стороне клиента и сервера для ускорения загрузки ресурсов.
3. **Lazy Loading**: Отложенная загрузка ресурсов, которые не нужны сразу при загрузке страницы.
4. **Оптимизация изображений**: Используйте современные форматы изображений и оптимизируйте их размер.
5. **CDN**: Используйте сети доставки контента для быстрой загрузки ресурсов.

### Оптимизация на уровне кода:
1. **Debouncing и Throttling**: Оптимизация обработчиков событий, особенно полезно для событий скроллинга и ввода в поля.
2. **Использование Web Workers**: Выполнение тяжелых задач в фоновом потоке.
3. **Пагинация и виртуализация списков**: Отображение только видимых элементов списка для улучшения производительности.
4. **Мемоизация**: Кеширование результатов функций для предотвращения повторных вычислений.

### Оптимизация во Vue:

1. **Компонентный уровень**: Используйте `v-if` и `v-show` для условного рендеринга и уменьшения нагрузки на DOM.
2. **Async Components**: Асинхронная загрузка компонентов, которые не нужны сразу.
3. **Computed Properties**: Используйте вычисляемые свойства для оптимизации повторных вычислений.
4. **Ключи в списках**: Всегда используйте `key` атрибут при рендеринге списков для оптимизации процесса обновления DOM.

Это далеко не исчерпывающий список, и существует множество других техник и инструментов для оптимизации производительности.
Оптимизация на уровне кода включает в себя различные техники и практики, которые помогают улучшить производительность приложения без изменения его функциональности. Вот подробнее о некоторых из них:

### Debouncing и Throttling
1. **Debouncing**: Эта техника полезна, когда вы хотите ограничить количество вызовов функции, которая может быть вызвана часто. Например, при вводе в текстовое поле.
   ```javascript
   let timeout;
   function debounce(func, delay) {
     clearTimeout(timeout);
     timeout = setTimeout(() => func(), delay);
   }
   ```
   
2. **Throttling**: Это ограничивает выполнение функции до одного раза в заданный период времени. Хорошо подходит для оптимизации обработчиков скроллинга.
   ```javascript
   let lastCall = 0;
   function throttle(func, delay) {
     const now = new Date().getTime();
     if (now - lastCall < delay) return;
     lastCall = now;
     return func();
   }
   ```

### Web Workers
Web Workers — это механизм в веб-технологиях, который позволяет выполнять скрипты в фоновом режиме, параллельно с основным потоком выполнения. Это означает, что вы можете выполнять длительные или сложные задачи без блокировки пользовательского интерфейса.
Web Workers работают в отдельном потоке, изолированном от основного потока. Они не имеют доступа к DOM, но могут обмениваться данными с основным потоком через систему сообщений (`postMessage` и `onmessage`).

Чтобы создать Web Worker, используйте конструктор `Worker`:

```javascript
const worker = new Worker('worker.js');
```

В файле `worker.js`:
```javascript
self.addEventListener('message', function(event) {
  // Обработка сообщения от основного потока
  const data = event.data;
  
  // Выполнение каких-либо действий
  
  // Отправка результата обратно в основной поток
  self.postMessage(result);
});
```

В основном потоке:
```javascript
// Отправка данных в worker
worker.postMessage(data);

// Получение данных от worker
worker.addEventListener('message', function(event) {
  const result = event.data;
  // Обработка результата
});
```

**Преимущества:**
- Параллельное выполнение кода.
- Не блокируют основной поток.
- Поддерживаются большинством современных браузеров.

**Ограничения:**
- Нет доступа к DOM.
- Нет доступа к некоторым объектам окна, таким как `window`, `document`, и `parent`.

Во Vue и Nuxt Web Workers могут быть полезными для выполнения тяжелых вычислений или обработки данных в фоновом режиме. Вы можете создать Web Worker внутри метода или жизненного цикла компонента.

### Пагинация и Виртуализация Списков

1. **Пагинация**: Отображение только части данных и загрузка остальных по мере необходимости.
  
2. **Виртуализация**: Отображение только тех элементов списка, которые видны пользователю. Это существенно улучшает производительность при работе с большими списками.

### Мемоизация

Это техника, при которой результаты тяжелых функций кешируются. Если функция вызывается повторно с теми же аргументами, возвращается кешированный результат.
```javascript
function memoize(func) {
  const cache = {};
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache[key]) return cache[key];
    const result = func(...args);
    cache[key] = result;
    return result;
  };
}
```

Эти методы могут быть применены в различных языках и фреймворках, включая JavaScript и его библиотеки, такие как Vue, React и другие. Они помогут улучшить отзывчивость интерфейса, уменьшить время загрузки и обеспечить более плавную работу вашего приложения.
***
## RegExp
Регулярные выражения (или regex) в JavaScript представляют собой мощный инструмент для работы с текстом. Они используются для поиска, замены и разделения строк, а также для проверки соответствия определенным паттернам.

Регулярное выражение создается через литерал регулярного выражения или через конструктор RegExp. Вот примеры обоих способов:
```
// Литерал регулярного выражения
const regex1 = /abc/;

// Конструктор RegExp
const regex2 = new RegExp('abc');
```

Регулярные выражения в JavaScript могут использовать различные специальные символы и конструкции. Вот несколько примеров:

- `.` соответствует любому символу, кроме перевода строки.
- `*` соответствует нулю или более повторениям предыдущего символа или группы.
- `+` соответствует одному или более повторениям предыдущего символа или группы.
- `?` делает предыдущий символ или группу необязательными (то есть, соответствует нулю или одному повторению).
- `^` соответствует началу строки.
- `$` соответствует концу строки.
- `\d` соответствует любой цифре (то же самое, что и `[0-9]`).
- `\w` соответствует любому словесному символу (то есть, любой букве, цифре или подчеркиванию).
- `\s` соответствует любому пробельному символу.
- `[]` создает группу символов, и соответствует любому символу в группе.
- `()` создает группу, и все внутри группы работает как единое целое.
- `|` работает как логическое "ИЛИ". Паттерн соответствует либо выражению до `|`, либо после.
- `{n}` соответствует ровно n повторениям предыдущего символа или группы.
- `{n,}` соответствует n или более повторениям.
- `{n,m}` соответствует от n до m повторений.

В JavaScript есть несколько методов для работы с регулярными выражениями:

- `regex.test(string)`: Возвращает `true`, если в строке есть совпадение с регулярным выражением, иначе `false`.
- `string.match(regex)`: Возвращает массив совпадений, или `null`, если совпадений нет.
- `string.replace(regex, replacement)`: Заменяет совпадения с регулярным выражением на replacement в строке.
- `string.split(regex)`: Разбивает строку на массив строк по совпадениям с регулярным выражением.
- `regex.exec(string)`: Возвращает результат поиска совпадения с регулярным выражением в виде массива или `null`, если совпадений нет.

Вот пример использования регулярного выражения для поиска всех чисел в строке:
```
const str = 'There are 3 cats, 4 dogs, and 5 birds.';
const numbers = str.match(/\d+/g); // ["3", "4", "5"]
```

В этом примере `\d+` соответствует одной или более цифре, а `g` является флагом, который означает "глобальный поиск" (то есть, искать все совпадения, а не только первое).
***
## Cookies
(куки) – это небольшие текстовые файлы, которые серверы веб-сайтов используют для хранения информации на компьютере пользователя. Они были введены в 1994 году Нетскейпом.

Когда пользователь посещает веб-сайт, сервер этого сайта может отправить куки, которые браузер пользователя сохранит. При последующих посещениях этого сайта браузер отправит эти куки обратно на сервер. Это позволяет сайту "запомнить" информацию о посещении, что может быть полезно для многих функций, таких как сохранение состояния входа в систему, сохранение настроек пользователя, отслеживание прогресса пользователя через сайт и многое другое.

### Использование куки в JavaScript

В JavaScript вы можете управлять куки с помощью свойства `document.cookie`.

**Создание куки:**
```
document.cookie = "username=John Doe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/";
```
Это создаст куки с именем "username", значением "John Doe", сроком действия до 18 декабря 2023 года, который будет доступен на всем сайте (`path=/`).

**Чтение куки:**
```
let allCookies = document.cookie;
```
Это вернет все куки в виде строки.
**Удаление куки:**
```
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
```
Удалить куки можно, установив его срок действия на дату в прошлом.

Важно отметить, что куки могут иметь ряд ограничений по безопасности и конфиденциальности. В частности, браузеры предотвращают доступ к куки с других доменов. Кроме того, новые стандарты, такие как `SameSite`, добавленные для улучшения безопасности куки, могут повлиять на то, как куки могут быть использованы для отслеживания пользователей через сайты.

Также существуют альтернативы куки, такие как `localStorage` и `sessionStorage`, которые могут быть лучшим выбором для некоторых сценариев использования.
***
## `localStorage` и `sessionStorage`
являются частью Web Storage API, предоставляемого браузерами, который позволяет веб-сайтам хранить данные в браузере пользователя. Эти два механизма хранения очень похожи, но имеют одно важное отличие в отношении продолжительности хранения информации.

- **localStorage**: Данные, сохраненные в localStorage, не имеют срока действия. Они остаются в браузере и не удаляются, даже если пользователь закрывает браузер или перезагружает компьютер. Информация, сохраненная в localStorage, остается доступной, пока ее явно не удалит веб-сайт или пользователь. Это делает localStorage хорошим выбором для сохранения долгосрочной информации, такой как предпочтения пользователя на веб-сайте.
```
// Сохранение данных в localStorage
localStorage.setItem('key', 'value');

// Получение данных из localStorage
let data = localStorage.getItem('key');

// Удаление данных из localStorage
localStorage.removeItem('key');

// Очистка всех данных из localStorage
localStorage.clear();
```
**sessionStorage**: В отличие от localStorage, данные в sessionStorage удаляются, как только закрывается вкладка браузера, в которой работает веб-сайт. Это делает sessionStorage полезным для хранения информации, которая должна оставаться только на протяжении одной "сессии" просмотра веб-сайта, например, информация о пользователе, вошедшем в систему.
```
// Сохранение данных в sessionStorage
sessionStorage.setItem('key', 'value');

// Получение данных из sessionStorage
let data = sessionStorage.getItem('key');

// Удаление данных из sessionStorage
sessionStorage.removeItem('key');

// Очистка всех данных из sessionStorage
sessionStorage.clear();
```
И `localStorage`, и `sessionStorage` могут хранить только строки. Если вам нужно сохранить более сложные структуры данных, такие как объекты или массивы, вы должны сначала преобразовать их в строку с помощью `JSON.stringify()`, а затем снова преобразовать их в объект с помощью `JSON.parse()` при извлечении.
***
## Сборщик мусора
— это механизм автоматического управления памятью, доступный во многих языках программирования, включая JavaScript. Основная задача сборщика мусора — автоматически высвобождать память, которая больше не используется программой.
В JavaScript сборщик мусора определяет, когда объект становится недоступным и автоматически освобождает занятую им память. Объект считается недоступным, когда на него нет ссылок или когда он не может быть достигнут из корневого объекта.
Сборка мусора в JavaScript в основном основана на понятии "достижимости". Объект считается достижимым, если существует цепочка ссылок от корневых объектов до этого объекта. Корневыми объектами являются встроенные объекты, такие как `global` и `this`.

Пример:
```
let user = {
  name: "John"
};

user = null; // теперь объект {name: "John"} становится недоступным и может быть удален сборщиком мусора
```
Однако стоит заметить, что даже если объект недоступен, это не обязательно означает, что он сразу же будет удален из памяти. Время, когда сборщик мусора начинает работать, зависит от реализации JavaScript движка.
***
## `requestIdleCallback` 
— это метод, предоставляемый браузером, который позволяет запланировать выполнение функции во время "простоя" браузера. Это означает, что ваш код будет выполнен, когда браузер будет готов к этому, и не будет занимать ресурсы, когда они нужны для других, более приоритетных задач, таких как обработка событий или обновление интерфейса.

Этот метод особенно полезен для задач, которые не являются критическими и могут быть отложены, но которые все же хотелось бы выполнить как можно скорее.

Пример использования:

```javascript
requestIdleCallback(function(idleDeadline) {
  while (idleDeadline.timeRemaining() > 0) {
    // выполнить некоторую работу
  }
});
```

В этом примере `idleDeadline` — это объект, предоставляемый браузером, который содержит метод `timeRemaining()`. Этот метод возвращает количество времени (в миллисекундах), которое осталось до конца текущего "простоя".

Таким образом, `requestIdleCallback` позволяет оптимизировать производительность, выполняя некритичные задачи только тогда, когда у браузера есть свободные ресурсы.

Для дополнительной информации вы можете обратиться к [документации MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback).

Этот метод полезен в ситуациях, когда вы хотите оптимизировать производительность и не мешать основным задачам страницы.
***
### Elasticsearch
— это распределенная система поиска и аналитики, основанная на технологии Lucene. Она предоставляет механизм для индексации, хранения и поиска данных, а также различные возможности для аналитики. Elasticsearch часто используется в комбинации с другими технологиями, такими как Logstash и Kibana, для создания полноценных решений для логирования, мониторинга и аналитики (ELK Stack или Elastic Stack).

### Основные характеристики:

- **Масштабируемость**: Elasticsearch может масштабироваться горизонтально, что позволяет обрабатывать большие объемы данных.
- **Полнотекстовый поиск**: Одна из сильных сторон Elasticsearch — возможность выполнения сложных запросов для полнотекстового поиска.
- **Реальное время**: Elasticsearch способен индексировать и предоставлять доступ к данным практически в реальном времени.
- **RESTful API**: Для взаимодействия с Elasticsearch обычно используется RESTful API, что делает его легко интегрируемым с различными технологиями и языками программирования.
- **Гибкость**: Elasticsearch не имеет жесткой схемы данных, что позволяет легко адаптироваться к различным типам данных.

### SOLID

SOLID — это акроним, представляющий пять основных принципов объектно-ориентированного программирования и проектирования:

1. **S**ingle Responsibility Principle (Принцип единственной ответственности) — у класса должна быть только одна причина для изменения.
2. **O**pen/Closed Principle (Принцип открытости/закрытости) — классы должны быть открытыми для расширения, но закрытыми для модификации.
3. **L**iskov Substitution Principle (Принцип подстановки Барбары Лисков) — объекты должны быть заменяемыми на экземпляры их подтипов.
4. **I**nterface Segregation Principle (Принцип разделения интерфейса) — клиенты не должны зависеть от интерфейсов, которые они не используют.
5. **D**ependency Inversion Principle (Принцип инверсии зависимостей) — зависимости должны строиться относительно абстракций, а не деталей.

### DRY (Don't Repeat Yourself)
Этот принцип гласит, что каждая часть знания или логики должна иметь единственное, недвусмысленное и авторитетное представление в системе. Следование этому принципу помогает избежать дублирования кода.

### KISS (Keep It Simple, Stupid)
Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Сложность должна добавляться только тогда, когда это абсолютно необходимо.

### YAGNI (You Aren't Gonna Need It)
Этот принцип предлагает не добавлять функциональность, пока она не действительно нужна. Он помогает избежать перегрузки системы ненужными возможностями и упрощает ее поддержку.

## RxJS 
(Reactive Extensions for JavaScript) — это библиотека для работы с асинхронными операциями и потоками данных в JavaScript. Она предоставляет удобные абстракции для комбинирования, создания, фильтрации и преобразования потоков данных, называемых Observables.

### Основные концепты:

1. **Observable**: Представляет собой поток данных или событий, на который можно подписаться.
2. **Observer**: Объект с методами, которые будут вызываться при получении новых данных, ошибки или завершения потока.
3. **Subscription**: Подписка на Observable, которая позволяет управлять жизненным циклом наблюдения.
4. **Operators**: Функции, которые позволяют преобразовывать или комбинировать Observables.

### Пример:

```javascript
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

const source$ = of(1, 2, 3);
const transformed$ = source$.pipe(map(x => x * 2));

const subscription = transformed$.subscribe(
  value => console.log(`Received: ${value}`),
  error => console.log(`Error: ${error}`),
  () => console.log('Completed')
);

// Output:
// Received: 2
// Received: 4
// Received: 6
// Completed
```


3. Как вы подходите к адаптивной и отзывчивой веб-разработке?
4. Какие подходы к управлению состоянием вы использовали в своих проектах (Redux, Vuex, Context API, MobX и т.д.)?
5. Какие типы тестирования вы используете в своем процессе разработки (unit, integration, end-to-end)?
6. Как вы обычно организуете свой код и структуру проекта?
7. Расскажите о вашем опыте работы с серверными API (REST, GraphQL).
8. Можете ли вы объяснить, как работает event loop в JavaScript?
9. Какие методы оптимизации загрузки и выполнения JavaScript вы использовали?
10. Расскажите о вашем опыте работы с системами сборки и инструментами (Webpack, Rollup, Parcel).
11. Как вы обрабатываете ошибки в JavaScript и как вы обрабатываете их на UI?
12. Расскажите о вашем опыте работы с CSS препроцессорами и/или CSS-in-JS решениями.
13. Как вы подходите к доступности в веб-разработке?
14. Можете ли вы объяснить принципы работы Promise и async/await в JavaScript?
15. Каков ваш опыт работы с типизацией в JavaScript (TypeScript, Flow)?
16. Какие принципы SOLID вы применяете в своей работе?
17. Как вы оцениваете качество кода и какие инструменты вы используете для его улучшения?
18. Как вы работаете с легаси-кодом и какие стратегии применяете для его рефакторинга?
19. Расскажите о вашем опыте работы в агиле или других методологиях разработки.
20. Как вы подходите к передаче знаний младшим или менее опытным разработчикам в команде?

