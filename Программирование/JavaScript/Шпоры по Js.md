## Типы  данных:
	1. String 
	2. Number (Целочесленные, с плавающей точкой. Диапозон: от -9 007 199 254 740 991 до 9007199254740991)
		1. Infinity (Математическая бесконечность. Получить: 1/0, или задать его явно)
		2. NaN (Означает вычислительную ошибку 'string'/2)
	3. BigInt
	4. Boolean
	5. Null - typeof(null) // Object - ошибка, допущеная создателем JS
	6. Undefined
	7. Symbol
	8. Object - подтип: function 

## Методы [ ]
	1. arr.push(...items) – добавляет элементы в конец,
	2. arr.pop() – извлекает элемент из конца,
	3. arr.shift() – извлекает элемент из начала,
	4. arr.unshift(...items) – добавляет элементы в начало.
	5. arr.splice(1, 1, ...items); - начиная с индекса 1, удалить 1 элемент, вставить items
	6. arr.slice([start], [end]) - return new arr, в который копирует все элементы с индекса start до end. arr.slice() создаёт копию []
	7. arr.concat(arg1, arg2...) create new [], в который копирует данные из других [] и дополнительные значения.
	8. arr.forEach(function(item, index, array) { // ... делать что-то с item }) позволяет запускать функцию для каждого элемента массива.
	9. arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.
	10. arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
	11. arr.find(function(item, index, array) { // если true - возвращается первый элемент и перебор прерывается, иначе возвращается undefined });
	12. arr.findIndex(function(item, index, array) { // начинается поиск с начала, возвращается индекс, иначе возвращается -1 });
	13. arr.findLastIndex(function(item, index, array) { // начинается поиск с конца, возвращается индекс, иначе возвращается -1 });
	14. arr.filter // let results = arr.filter(function(item, index, array) { // если `true` -- элемент добавляется к results и перебор продолжается // возвращается [] в случае, если ничего не найдено });
	15. arr.map // Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции. let result = arr.map(function(item, index, array) { // возвращается новое значение вместо элемента });
	16. arr.sort() // сортирует массив на месте, меняя в нём порядок элементов.
	17. arr.reverse() - меняет порядок элементов в arr на обратный
	18. arr.split() - разбивает строку по заданному разделителю и возвращает массив элементов
	19. arr.join() - склеивает массив в строку по указанному разделителю 
	20. arr.reduce() - используются для вычисления единого значения с начала [] на основе всего массива arr.reduce(function(accumulator, item, index, array) { // ... }, [initial]) let result = arr.reduce((sum, current) => sum + current, 0)
	21. arr.reduceright() - используются для вычисления единого значения с конца [] на основе всего массива arr.reduce(function(accumulator, item, index, array) { // ... }, [initial]) let result = arr.reduce((sum, current) => sum + current, 0)
***
## Различия let const и var
В JavaScript, `var`, `let` и `const` - это три способа объявления переменных, каждый из которых имеет свои особенности.
**var**:
- `var` объявляет переменную в рамках области видимости функции, если она объявлена внутри функции. Если `var` объявлена вне функции, то она становится глобальной переменной.
- Переменные, объявленные с использованием `var`, поднимаются (hoisting) к началу своей области видимости. Это означает, что переменная может быть объявлена после того, как она была использована.
- Переменные, объявленные как `var`, могут быть переопределены.
**let**:
- `let` объявляет переменную в рамках блочной области видимости. Это означает, что переменная, объявленная внутри блока кода (например, внутри цикла или условного оператора), не существует за пределами этого блока.
- Переменные, объявленные как `let`, не поднимаются к началу своей области видимости.
- Переменные, объявленные как `let`, могут быть переопределены в рамках своей области видимости.
**const**:
- `const` также объявляет переменную в рамках блочной области видимости, как и `let`.
- Переменные, объявленные как `const`, не поднимаются к началу своей области видимости.
- Переменные, объявленные как `const`, не могут быть переопределены. Это означает, что после их инициализации, вы не можете изменить их значение. Это делает `const` хорошим выбором для переменных, значение которых не должно меняться.
В общем, если вам не нужно переопределять переменную и она не должна меняться, используйте `const`. Если вам нужна переменная, которую можно переопределить, используйте `let`. Использование `var` стало менее распространенным из-за его свойств, которые могут привести к ошибкам и трудностям в отладке.
***
## Архитектура программного обеспечения 
- это структурный и концептуальный вид программного обеспечения, определяющий его компоненты, их функции и взаимодействие. Вот несколько типов архитектуры программного обеспечения:

1. **Многослойная архитектура:** Структура программного обеспечения разделяется на три основных слоя: представление, бизнес-логика и доступ к данным. Это обеспечивает отделение областей ответственности и упрощает тестирование.
2. **Микро сервисная архитектура:** Приложение состоит из набора независимых микро сервисов, каждый из которых выполняет определенную функцию и взаимодействует с другими через API. Это улучшает масштабируемость и отказоустойчивость, но требует сложной координации и управления сервисами.
3. **Модульная архитектура:** Приложение разделено на независимые модули или компоненты, каждый из которых отвечает за конкретную функциональность. Это упрощает разработку и поддержку, так как каждый модуль может быть разработан и тестирован независимо.
4. **Event-Driven Architecture (EDA):** Система состоит из компонентов, которые взаимодействуют друг с другом через события. Это позволяет системе быть гибкой и масштабируемой, но может усложнить проектирование и отладку системы.
5. **Serverless Architecture:** Этот тип архитектуры позволяет разработчикам создавать и запускать приложения без необходимости управлять серверами. Это упрощает развертывание и масштабирование, но может ограничить гибкость и контроль.
6. **Service-Oriented Architecture (SOA):** Этот подход подразумевает разделение функциональности приложения на независимые службы, которые взаимодействуют друг с другом через стандартизованные протоколы. Это обеспечивает высокую модульность и масштабируемость, но может усложнить координацию и производительность.
7. **Monolithic Architecture:** В этой архитектуре все компоненты приложения объединены в одном программном пакете. Это упрощает разработку и тестирование, но может затруднить масштабирование и обновление приложения.
8. **N-Tier Architecture:** Это расширение многослойной архитектуры, где каждый слой размещается на отдельном сервере или на отдельной платформе. Это улучшает безопасность и производительность, но может усложнить конфигурацию и управление.
9. **Peer-to-Peer Architecture (P2P):** В этой архитектуре все узлы являются равноправными и могут выполнять функции как клиентов, так и серверов. Это обеспечивает высокую отказоустойчивость и распределение нагрузки, но может усложнить управление и безопасность.
10. **Model-View-Controller (MVC):** Это шаблон проектирования, который разделяет приложение на три основные компонента: модель (Model), представление (View) и контроллер (Controller). Это улучшает модульность и упрощает разработку и тестирование, но требует дополнительного планирования и конфигурации.

Выбор архитектуры зависит от многих факторов, включая требования к приложению, доступные ресурсы, навыки и опыт команды разработчиков, и многое другое.
***
## Архитектурные стили приложения

#### **RESTful (Representational State Transfer)** 
- это архитектурный стиль для разработки веб-сервисов, который опирается на принципы и ограничения веб-протокола HTTP. Он описывает подход к проектированию и организации взаимодействия между клиентом и сервером.

Основные принципы RESTful-архитектуры:
1. **Ресурсы (Resources)**: В REST, данные или сервисы, которые приложение может использовать, называются ресурсами. Каждый ресурс идентифицируется с помощью уникального URL (Uniform Resource Locator), который является "адресом" ресурса.
2. **HTTP-методы (HTTP Methods)**: REST использует стандартные HTTP-методы для работы с ресурсами. Это включает в себя GET (получение данных), POST (создание новых данных), PUT (обновление существующих данных) и DELETE (удаление данных).
3. **Стандартные форматы данных**: REST API обычно используют стандартные форматы данных, такие как JSON (JavaScript Object Notation) или XML (eXtensible Markup Language) для отправки и получения данных.
4. **Stateless (Без сохранения состояния)**: Одной из ключевых особенностей REST является то, что сервер не сохраняет информацию о состоянии между различными запросами. Это означает, что каждый запрос должен содержать всю необходимую информацию для его обработки.
5. **Client-Server Architecture (Архитектура клиент-сервер)**: REST API основаны на архитектуре клиент-сервер, где клиент (обычно веб-браузер или другое приложение) отправляет запросы на сервер, который обрабатывает эти запросы и возвращает ответы обратно клиенту.
6. **Cacheable (Кешируемость)**: Ответы от сервера могут быть кешированы (или сохранены) на стороне клиента для улучшения производительности.

RESTful-сервисы организуют данные в виде ресурсов, которые могут быть идентифицированы уникальными URI. Клиенты могут выполнять операции над этими ресурсами, отправляя запросы HTTP на соответствующие URI, используя соответствующие методы (GET, POST, PUT, DELETE) и передавая данные, когда это необходимо.

В дополнение к REST, существуют и другие архитектурные стили и паттерны, которые используются при проектировании систем. Вот несколько из них:

1. **SOAP (Simple Object Access Protocol):** Этот стиль используется для обмена структурированными информационными сообщениями через веб-сервисы. SOAP может использоваться с любым протоколом передачи данных, хотя наиболее распространено его использование с HTTP.
2. **GraphQL:** Это открытый стиль API, разработанный Facebook, который позволяет клиентам определять структуру данных, которые они требуют, и объединять множественные запросы в один. Это может привести к более эффективному использованию пропускной способности по сравнению с REST.
3. **Event-Driven Architecture (EDA):** В этом стиле архитектуры, основной упор делается на производство, обнаружение и реакцию на события, которые могут происходить в приложении. Это приводит к высокой адаптивности и может быть полезно в реальном времени и асинхронных системах.
4. **Service-Oriented Architecture (SOA):** SOA предполагает разделение функциональности приложения на отдельные сервисы, каждый из которых выполняет конкретную бизнес-функцию и взаимодействует с другими сервисами через веб-сервисы.
5. **Hexagonal Architecture (also known as Ports and Adapters):** Этот стиль архитектуры направлен на создание приложений с четким разделением между внутренней логикой приложения и слоями адаптеров, которые обеспечивают связь с внешним миром (например, базами данных, веб-сервисами и т.д.).
6. **Microkernel Architecture (Plug-in Architecture):** Этот стиль архитектуры делит систему на набор ядерных компонентов и набор плагинов, которые могут быть динамически добавлены для расширения функциональности.

Эти стили и паттерны могут быть использованы в различных комбинациях и адаптированы под конкретные требования и обстоятельства проекта.

***
## HTTP-запрос
HTTP запрос можно осуществить различными способами:
1. Fetch API: Предоставляет простой и мощный интерфейс для выполнения HTTP-запросов. Поддерживается в современных браузерах.
2. XMLHttpRequest (XHR): Старый, но все еще широко используемый способ выполнения асинхронных запросов на сервер. Поддерживается во всех современных браузерах.
3. Axios: Библиотека для выполнения HTTP-запросов, предоставляющая удобный API для выполнения запросов как в браузере, так и на сервере.
4. jQuery AJAX: jQuery - это JavaScript-библиотека, которая предоставляет удобные методы для выполнения AJAX-запросов.
5. Superagent: Легковесная библиотека для выполнения запросов на сервер с поддержкой промисов.
6. node-fetch: Библиотека для выполнения запросов на сервер в Node.js, основанная на Fetch API.
7. got: Мощная библиотека для выполнения HTTP-запросов с поддержкой промисов и потоковых данных.
8. reqwest: Простая и легковесная библиотека для выполнения AJAX-запросов в браузере.
9. Angular HttpClient: Модуль Angular для выполнения HTTP-запросов в браузере.
10. Vue Resource: Официальный HTTP-клиент Vue.js для выполнения запросов на сервер.
11. Ember Data: Библиотека для работы с данными и выполнения запросов на сервер в фреймворке Ember.js.
12. Meteor HTTP: Встроенный модуль в платформе Meteor для выполнения HTTP-запросов на сервер.
	HTTP-запрос — это сообщение, которое отправляется клиентом (обычно браузером) на сервер в процессе обмена данными по протоколу **HTTP (Hypertext Transfer Protocol)**, который является основой любого обмена данными в Интернете.
	HTTP-запросы состоят из различных частей, включая:
	1. **Метод запроса**: Это тип операции, который клиент хочет выполнить. Существует несколько методов HTTP, включая GET (запрос данных от сервера), POST (отправка данных на сервер), PUT (обновление существующих данных на сервере), DELETE (удаление данных на сервере) и другие.
	2. **URL (Uniform Resource Locator)**: URL определяет, куда направить запрос. Это может включать доменное имя сервера и путь к конкретному ресурсу на сервере.
	3. **Заголовки**: Заголовки могут содержать различные метаданные о запросе, такие как тип содержимого, кодировку, куки и другие данные.
	4. **Тело запроса**: Некоторые методы HTTP (например, POST и PUT) могут включать тело запроса, которое содержит данные, отправляемые на сервер. В запросах с методом GET тела нет.
Вот наиболее распространенные HTTP-методы и их назначение:
1. **GET**: Используется для получения данных с сервера. Запросы GET не должны изменять состояние сервера и могут содержать параметры в URL-адресе.
```
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => { console.log(data); // Получение данных с сервера })
  .catch(error => { console.error(error) });
```
2. **POST**: Используется для отправки данных на сервер для создания новых ресурсов. POST-запросы могут содержать данные в теле запроса и обычно приводят к изменению состояния сервера.
```
const newData = { name: 'John', age: 30 };

fetch('https://api.example.com/data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(newData)
})
  .then(response => response.json())
  .then(data => { console.log(data); // Создание нового ресурса на сервере })
  .catch(error => { console.error(error) });
```
3. **PUT**: Используется для отправки данных на сервер с целью полного обновления существующего ресурса. PUT-запросы содержат данные в теле запроса и перезаписывают текущую версию ресурса.
```
const updatedData = { name: 'John Doe', age: 35 };

fetch('https://api.example.com/data/1', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(updatedData)
})
  .then(response => response.json())
  .then(data => { console.log(data) // Обновление существующего ресурса на сервере })
  .catch(error => { console.error(error) });
```
4. **PATCH**: Используется для отправки данных на сервер с целью частичного обновления существующего ресурса. PATCH-запросы содержат данные в теле запроса и применяют изменения к текущей версии ресурса.
5. **DELETE**: Используется для удаления существующего ресурса на сервере.
```
fetch('https://api.example.com/data/1', {  method: 'DELETE' })
  .then(response => { console.log('Ресурс успешно удален') })
  .catch(error => { console.error(error) });
```
6. **OPTIONS**: Используется для получения информации о доступных опциях или методах, поддерживаемых сервером для определенного ресурса.
7. **HEAD**: Похож на GET-запрос, но возвращает только заголовки ответа, без фактического содержимого.
8. **TRACE**: Используется для эхо-тестирования, когда сервер возвращает входящий запрос в виде ответа, позволяя клиенту видеть, как его запросы проходят через различные системы.
9. **CONNECT**: Используется для установки соединения с сервером через прокси.
***
## **Помимо HTTP есть так же:**
1. **HTTPS (HyperText Transfer Protocol Secure)**: Это просто HTTP, но с добавленным слоем безопасности SSL (Secure Sockets Layer) или TLS (Transport Layer Security), которые шифруют данные, передаваемые между клиентом и сервером.
2. **FTP (File Transfer Protocol)**: Этот протокол используется для передачи файлов между клиентом и сервером. Он поддерживает передачу больших файлов и может быть настроен для работы в активном или пассивном режиме.
3. **SMTP (Simple Mail Transfer Protocol)**: Этот протокол используется для отправки электронной почты. Обычно SMTP используется для отправки сообщений, в то время как POP3 или IMAP используются для их получения.
4. **WebSockets**: Этот протокол обеспечивает двустороннее взаимодействие между клиентом и сервером в режиме реального времени. Он был разработан для решения проблем, с которыми столкнулись разработчики, пытающиеся реализовать сложные веб-приложения с использованием HTTP.
5. **gRPC (Google Remote Procedure Call)**: Этот протокол, разработанный Google, использует протокол HTTP/2 и поддерживает множество языков программирования. Он использует Protobuf (Protocol Buffers) для эффективной сериализации структурированных данных и поддерживает функции, такие как аутентификация, нагрузочное балансирование и отмена запросов.
6. **MQTT (Message Queuing Telemetry Transport)**: Это протокол передачи сообщений, который часто используется в системах IoT (Internet of Things) для обмена данными между устройствами с низкими требованиями к пропускной способности и энергопотреблению.
***
## **JSON (JavaScript Object Notation)** и **XML (eXtensible Markup Language)** 
	- это два распространенных формата данных, используемых для хранения и передачи данных в структурированном виде. Оба эти формата поддерживают структуры данных, такие как массивы и объекты, и могут быть легко прочитаны людьми.

1. **JSON:** Этот формат основан Дугласом Крокфордом (книга ## «Как устроен JavaScript») на синтаксисе JavaScript и представляет собой текстовый формат, который легко читается и записывается. JSON стал очень популярным для обмена данными между браузером и сервером, поскольку его легко использовать в JavaScript и других языках программирования. Пример данных в формате JSON:
```
{
    "name": "John",
    "age": 30,
    "city": "New York"
}
```
2. **XML:** Это более старый и более гибкий формат, чем JSON. Он позволяет создавать собственные теги и поддерживает атрибуты, пространства имен и схемы для валидации данных. Однако XML более громоздкий по сравнению с JSON и требует больше текста для представления тех же данных. Пример данных в формате XML:
```
<person>
    <name>John</name>
    <age>30</age>
    <city>New York</city>
</person>
```
Оба этих формата широко используются в различных областях, включая веб-разработку, конфигурационные файлы и межсерверные передачи данных. Однако JSON стал более популярным в современной веб-разработке, особенно в RESTful API, благодаря своей простоте и совместимости с JavaScript.
***
## **Что такое замыкание (closure) в JavaScript?**
Замыкание в JavaScript - это особенность, которая позволяет функции сохранять информацию о переменных, которые были доступны в момент её создания. Это означает, что функция может использовать эти переменные, даже если они уже не существуют в области видимости.
```
function outerFunction() {
  let counter = 0;
  return function () {
    counter++
    console.log(counter);
  }
}
let closureExample = outerFunction();
closureExample(); // 1 closureExample(); // 2

function multiply(a) {
  return function(b) {
    return a * b
  }
}
const multiplyByTwo = multiply(2) console.log(multiplyByTwo(2)) // 4
const multiplyByTree = multiply(3) console.log(multiplyByTree(3)) // 9

```
Замыкания полезны во многих случаях, например, при создании приватных переменных и функций, при реализации модульного паттерна или при работе с асинхронным кодом, чтобы сохранить состояние между вызовами функций.
***
## **Что такое Map и Set**
Данные в Map хранятся в виде Хэш таблицы, в результате чего доступ к ним осуществляется быстрее, чем если бы данные были бы в объекте.
`Map` и `Set` являются двумя встроенными коллекциями в JavaScript, которые предоставляют удобные способы хранения и организации данных.

#### `Map` 
представляет собой коллекцию пар "ключ-значение", как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа. Особенности `Map`:

- Гарантирует уникальность ключей. Если попытаться добавить в `Map` значение с уже существующим ключом, старое значение будет заменено новым.
- Поддерживает итерацию по парам "ключ-значение" с помощью метода `forEach` или оператора `for...of`.
- Можно использовать любые типы данных в качестве ключей.
- Предоставляет методы для добавления, удаления и обновления пар "ключ-значение", а также для получения размера `Map` и проверки наличия определенного ключа.

Методы и свойства:
- [`new Map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Map) – создаёт коллекцию.
- [`map.set(key, value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set) – записывает по ключу `key` значение `value`.
- [`map.get(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get) – возвращает значение по ключу или `undefined`, если ключ `key` отсутствует.
- [`map.has(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has) – возвращает `true`, если ключ `key` присутствует в коллекции, иначе `false`.
- [`map.delete(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete) – удаляет элемент (пару «ключ/значение») по ключу `key`.
- [`map.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear) – очищает коллекцию от всех элементов.
- [`map.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size) – возвращает текущее количество элементов.

Пример использования `Map`:
```
const map = new Map();

map.set("name", "John");
map.set("age", 30);

console.log(map.get("name")); // Выводит "John"
console.log(map.size); // Выводит 2

map.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

map.delete("age");
console.log(map.has("age")); // Выводит false
```
## [Перебор Map](https://learn.javascript.ru/map-set#perebor-map)

Для перебора коллекции `Map` есть 3 метода:
- [`map.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys) – возвращает итерируемый объект по ключам,
- [`map.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values) – возвращает итерируемый объект по значениям,
- [`map.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries) – возвращает итерируемый объект по парам вида `[ключ, значение]`, этот вариант используется по умолчанию в `for..of`.
```
let recipeMap = new Map([ 
	["огурец", 500], 
	["помидор", 350], 
	["лук", 50] 
]);
// перебор по ключам (овощи) 
for (let vegetable of recipeMap.keys()) { 
	alert(vegetable); // огурец, помидор, лук 
} 
// перебор по значениям (числа) 
for (let amount of recipeMap.values()) { 
	alert(amount); // 500, 350, 50 
} 
// перебор по элементам в формате [ключ, значение] 
for (let entry of recipeMap) { 
	// то же самое, что и recipeMap.entries() 
	alert(entry); // огурец,500 (и так далее) 
}
```
Мы можем создать `Map` из обычного объекта следующим образом:
```
let obj = { name: "John", age: 30 }; 
let map = new Map(Object.entries(obj));
alert( map.get('name') ); // John
```
И можем сделать наоборот - создать объект из Map
```
let map = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);
let obj = Object.fromEntries(map.entries()); 
// obj = { огурец: 500, помидор: 350, лук: 50 }
```
#### `Set` 
представляет собой коллекцию уникальных значений любого типа данных. Основные особенности `Set`:

- Хранит только уникальные значения. При попытке добавить в `Set` уже существующее значение, оно будет проигнорировано.
- Поддерживает итерацию по значениям с помощью метода `forEach` или оператора `for...of`.
- Можно использовать любые типы данных в качестве значений.

Пример использования `Set`:
```
const set = new Set();

set.add("apple");
set.add("banana");
set.add("apple"); // Дубликат "apple" будет проигнорирован

console.log(set.size); // Выводит 2

set.forEach(value => {
  console.log(value);
});

set.delete("banana");
console.log(set.has("banana")); // Выводит false
```
Вот основные отличия между `Map` и `Set`:

1. Уникальность элементов: `Map` сохраняет уникальные пары "ключ-значение", тогда как `Set` хранит только уникальные значения.
2. Тип данных ключа: В `Map` ключами могут быть любые типы данных, включая примитивы и объекты. В `Set` значениями могут быть любые типы данных, но ключи и значения идентичны.
3. Итерация: `Map` предоставляет методы для итерации по парам "ключ-значение" с помощью `forEach` или `for...of`, в то время как `Set` позволяет итерироваться только по значениям.
4. Размер: `Map` имеет свойство `size`, которое возвращает количество пар "ключ-значение" в коллекции. У `Set` также есть свойство `size`, которое возвращает количество уникальных значений в коллекции.
5. Удаление элементов: В `Map` элементы можно удалить с помощью метода `delete`, передавая ключ в качестве аргумента. В `Set` элементы также удаляются с помощью метода `delete`, но в качестве аргумента передается значение.
6. Порядок элементов: `Map` сохраняет порядок добавления пар "ключ-значение". Это означает, что при итерации элементы будут возвращаться в том же порядке, в котором они были добавлены. В `Set` порядок элементов определяется порядком их добавления, но он не гарантирован и может быть изменен внутренней реализацией JavaScript.

Оба `Map` и `Set` предоставляют эффективные методы для добавления, удаления и поиска элементов. Выбор между `Map` и `Set` зависит от специфических потребностей вашего приложения и типа данных, которые вы хотите хранить. Если вам нужно хранить пары "ключ-значение" или требуется быстрый поиск по ключу, то `Map` будет предпочтительнее. Если вам нужно хранить только уникальные значения и вам не важен порядок, то `Set` будет более подходящим выбором.
Использование `Map` и `Set` позволяет эффективно хранить и манипулировать данными, обеспечивая быстрый доступ и уникальность значений или пар "ключ-значение". Выбор между `Map` и `Set` зависит от конкретных потребностей и требований вашего приложения.
* * *
## Event Loop 
- это концепция, лежащая в основе асинхронного программирования, которая позволяет JavaScript выполнять неблокирующие операции, несмотря на то, что сам язык является однопоточным.
В общем виде, Event Loop, или цикл событий, следует следующим этапам:

1. **Call Stack (Стек вызовов)**: Это место, где выполняется ваш JavaScript код. Когда функция вызывается, она помещается на вершину стека вызовов. Когда функция завершена, она удаляется из стека.
2. **Wep Apis**: Это структура данных, которая представляет большую область памяти, где осуществляется выделение памяти для объектов JavaScript.
3. **Callback Queue (Очередь обратного вызова)**: Это список задач, которые ожидают выполнения. Когда асинхронная функция завершает свою работу (например, Ajax-запрос, таймер и т.д.), она добавляет новую задачу в очередь.

Сам Event Loop делает следующее:

1. Проверяет, есть ли в стеке вызовов какие-либо функции для выполнения. Если есть, он запускает их одну за другой, пока стек не опустеет.
2. Когда стек пуст, он смотрит на очередь задач. Если в очереди есть задачи, Event Loop берет первую задачу из очереди и помещает ее в стек вызовов для выполнения.
3. Этот процесс повторяется бесконечно, вот почему это называется "циклом событий".

```
console.log('Start'); // 1

setTimeout(function() {
    console.log('Timeout 1'); // 5
}, 0);

Promise.resolve().then(function() {
    console.log('Promise 1'); // 3
}).then(function() {
    console.log('Promise 2'); // 4
});

console.log('End'); // 2

```
***

## AJAX
стоит за асинхронным JavaScript и XML (Asynchronous JavaScript And XML). Это набор методов разработки веб-приложений, позволяющих веб-страницам быстро обмениваться данными с веб-сервером без полной перезагрузки страницы. Это позволяет делать веб-приложения более быстрыми и отзывчивыми.

Основные особенности AJAX включают:

- Асинхронность: AJAX позволяет отправлять и получать данные в фоновом режиме (асинхронно) без влияния на отображение и поведение существующей страницы.
- Использование JavaScript и XMLHttpRequest: AJAX использует объект XMLHttpRequest для обмена данными с веб-сервером. JavaScript используется для выполнения AJAX-запроса и обработки ответа от сервера.
- Формат данных: хотя в названии AJAX упоминается XML, данные могут передаваться в любом формате, включая текст, HTML, XML, JSON и др.

Пример простого AJAX-запроса с использованием встроенного в браузеры объекта `XMLHttpRequest` может выглядеть следующим образом:
```
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4 && xhr.status == 200)
    console.log(xhr.responseText);
};
xhr.send();
```

***
### **Что такое "hoisting" в JavaScript?**
Hoisting или поднятие - это механизм в JavaScript, в котором переменные и объявления функций перемещаются вверх своего текущего контекста выполнения, что позволяет их использовать до их физического расположения в коде. Однако, для переменных инициализация не поднимается.
***
### **Что такое `this` в JavaScript?**
`this` в JavaScript – это ключевое слово, которое ссылается на объект, в контексте которого вызвана функция. В глобальном контексте `this` ссылается на глобальный объект (`window` в браузерах). В контексте объекта `this` ссылается на этот объект. Однако в стрелочных функциях `this` наследуется от окружающего контекста.
***
## Прототипы
Прототипное наследование в JavaScript - это такой способ передачи свойств и функций от одного объекта к другому. Все дело в том, что в JavaScript объекты могут иметь ссылки на другие объекты, которые называются "прототипами". Если у объекта отсутствует какое-то свойство или метод, JavaScript посмотрит в его прототипе, чтобы найти это свойство или метод. И если он там есть, объект получит доступ к нему. Это называется "наследованием" свойств и методов прототипа.

```
let animal = {
  eats: true,
  walk() {
    console.log("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal // наследуется от animal 
};

rabbit.walk(); // выводит "Animal walk"
console.log(rabbit.eats); // выводит true
```
Некоторые важные моменты:

1. **Цепочки прототипов:** JavaScript может искать свойства и методы далеко вглубь цепочки прототипов, если они отсутствуют в текущем объекте.
2. **Делегирование:** JavaScript не копирует свойства и методы из прототипа в объект, а просто использует их по мере необходимости. Это значит, что если вы что-то измените в прототипе, эти изменения отразятся на всех объектах, которые его используют.
3. **Прототипы и конструкторы:** Когда вы создаете объекты с помощью конструктора (т.е. функции, которая создает объект), у этой функции есть свойство `prototype`, которое используется как прототип для всех создаваемых объектов.

***
###  **Что такое обещания (promises) в JavaScript?**
Promise в JavaScript представляет собой объект, который обозначает итог выполнения асинхронной операции. Обещания могут находиться в одном из трех состояний: "ожидание", "исполнено" или "отклонено". Promises могут быть связаны в цепочки для выполнения серии асинхронных операций.
***
### **Что такое стрелочная функция в JavaScript?**
Стрелочные функции в JavaScript - это более короткий способ объявления функций. Они не связывают собственные значения `this`, `arguments`, `super` или `new.target`, что делает их идеальными для использования внутри функций высшего порядка и методов.
***
### **Что такое асинхронность в JavaScript?**
JavaScript является однопоточным языком, что означает, что он может обрабатывать только одну операцию за раз. Однако, благодаря механизмам, таким как обратные вызовы (callback functions), промисы (Promises) и асинхронные функции (Async/Await), он может обрабатывать асинхронные операции, позволяя выполнение других операций во время ожидания ответа.
***
### **Что такое функции высшего порядка в JavaScript?**
Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов и/или возвращают функции в качестве результата. Это ключевой аспект функционального программирования, и он используется во многих встроенных методах JavaScript, таких как `.map()`, `.filter()` и `.reduce()`.
***   
### **Что такое IIFE (Immediately Invoked Function Expression) в JavaScript?**
IIFE - это функциональное выражение, которое вызывается сразу после его определения. Это используется для создания приватного скоупа, чтобы избежать засорения глобального пространства имен и случайного перезаписывания переменных.
***
