## debounce()
- это техника в программировании, которая позволяет установить задержку между последним вызовом функции и ее фактическим выполнением. Это полезно в ситуациях, когда функция вызывается часто или множество раз, но требуется выполнить ее только один раз после определенного периода неактивности.
```
const fetchUrl = (url) => {
  console.log(`fetch url ${url}...`)
}
function debounce(callback, delay) {
  let timer = null;
  return (...args) => {
    clearTimeout(timer); // Очищаем предыдущий таймер, если он был установлен
    timer = setTimeout(() => {
      callback(...args); // Вызываем функцию callback после задержки
    }, delay);
  }
}

const fetching = debounce(fetchUrl, 1);

fetching(1); 
fetching(2); 
fetching(3); // Запускаем вызов функции fetchUrl с аргументом 3
```

### 1. **Палиндром**: 
Написать функцию, которая определяет, является ли введенная строка палиндромом.
```
function isPalindrome(str) {   
	// преобразует вводимую строку в нижний регистр и удаляет все не буквенные и числовые символы.
	str = str.toLowerCase().replace(/[\W_]/g, '');
	// разбивает строку на массив символов, переворачивает этот массив и объединяет его обратно в строку. 
	let reverseStr = str.split('').reverse().join('');
	// сравнивает исходную и обратную строки   
	return str === reverseStr; 
}
```

### 2. **Фибоначчи**: 
Написать функцию, которая возвращает n-е число в последовательности Фибоначчи.
```
function fibonacci(n) {
	//  возвращает `n`, если `n` меньше 2
	if (n < 2) {
		return n
	}
	// В противном случае она возвращает сумму двух предыдущих чисел в последовательности
	return fibonacci(n - 1) + fibonacci(n - 2)
}

```

### 3. **FizzBuzz**: 
Написать функцию, которая выводит числа от 1 до 100. 
Но для чисел, которые делятся на 3, вместо числа вывести "Fizz", а для чисел, которые делятся на 5 (но не на 3), вывести "Buzz". Если число делится и на 3, и на 5, вывести "FizzBuzz".
```
// Этот цикл перебирает числа от 1 до 100
for (let i = 1; i <= 100; i++) {
  let output = '';
  
  //Если число делится на 3, к выводу добавляется 'Fizz',
  if (i % 3 === 0) output += 'Fizz';
  
  // если делится на 5, то 'Buzz
  if (i % 5 === 0) output += 'Buzz';
  
  // Если число не делится ни на 3, ни на 5, выводится само число
  console.log(output || i);
}

```


### 4. **Сумма массива**: 
Написать функцию, которая принимает массив чисел и возвращает их сумму.
```
function sumArray(arr) {
  let sum = 0;
  // проходит через каждый элемент массива и добавляет его к сумме
  for(let i = 0; i < arr.length; i++){
    sum += arr[i];
  }
  // Затем возвращает сумму
  return sum;
}

```

## 5. **Анаграмма**: 
Написать функцию, которая принимает две строки и проверяет, являются ли они анаграммами друг для друга.
```
function isAnagram(str1, str2) {   
	let sortedStr1 = str1.toLowerCase().split('').sort().join('');   
	let sortedStr2 = str2.toLowerCase().split('').sort().join('');   
	return sortedStr1 === sortedStr2; 
}
```
Функция преобразует каждую строку в нижний регистр, разбивает ее на массив символов, сортирует массив и объединяет его обратно в строку. Затем функция сравнивает две отсортированные строки.

## 6. **Максимальное число в массиве**: 
Написать функцию, которая возвращает максимальное число в массиве.

```
function maxNumber(arr) {   
	return Math.max(...arr); 
}
```

Функция использует оператор расширения (`...`) для преобразования массива в отдельные аргументы, которые затем передаются в `Math.max`.

## 7. **Удаление дубликатов из массива**: 
Написать функцию, которая удаляет дубликаты из массива.

```
function removeDuplicates(arr) {   
	return [...new Set(arr)]; 
}
```

Функция использует объект Set для удаления дубликатов, затем преобразует его обратно в массив.

### 8. **Обращение строки**: 
Написать функцию, которая переворачивает строку.
```
function reverseString(str) {   
	return str.split('').reverse().join(''); 
}
```

Функция разбивает строку на массив символов, переворачивает массив и объединяет его обратно в строку.

### 9. **Поиск наибольшего общего делителя (НОД)**: 
Написать функцию, которая находит НОД двух чисел.
```
function gcd(a, b) {   
	if (!b) {     
		return a;   
	}   
	return gcd(b, a % b); 
}
```

Это рекурсивная функция, которая использует алгоритм Евклида для нахождения НОД.

### 10. **Факториал**: 
Написать функцию, которая вычисляет факториал числа.

```
function factorial(n) {   
	if (n === 0) {     
		return 1;   
	} else {     
		return n * factorial(n - 1);   
	} 
}
```

Это рекурсивная функция, которая умножает число `n` на факториал `n-1` до тех пор, пока `n` не достигнет 0.

### 11. **Проверка простого числа**: 
Написать функцию, которая проверяет, является ли число простым.

```
function isPrime(num) {   
	for(let i = 2, sqrt = Math.sqrt(num); i <= sqrt; i++)     
	if(num % i === 0) return false;    return num > 1; 
}
```

Эта функция проверяет, делится ли число на любое число от 2 до квадратного корня числа. Если число делится без остатка, оно не является простым.

### 12. **Найти сумму чисел в строке**: 
Написать функцию, которая находит сумму всех чисел в строке.

```
function sumNumbersInString(str) {   
	let sum = 0;   
	let numbers = str.match(/\d+/g);   
	if (numbers) {     
		sum = numbers.reduce((acc, curr) => acc + Number(curr), 0);   
	}   
	return sum; 
}
```

### 13. **Преобразование строки в верблюжий регистр (camelCase)**: 
Написать функцию, которая преобразует строку в верблюжий регистр.

```
function toCamelCase(str) {   
	return str.replace(/([-_]\w)/g, g => g[1].toUpperCase()); 
}
```

Функция использует регулярное выражение для поиска слов, предваренных "-" или "_", и преобразует первую букву этих слов в верхний регистр.

### 14. **Сортировка пузырьком**: 
Написать функцию, которая сортирует массив с помощью алгоритма сортировки пузырьком.

```
function bubbleSort(arr) {   
	let len = arr.length;   
	for (let i = len-1; i >= 0; i--){     
		for(let j = 1; j <= i; j++){       
		if(arr[j-1] > arr[j]) {           
			let temp = arr[j-1];           
			arr[j-1] = arr[j];           
			arr[j] = temp;        
		}     
	}   
	return arr; 
}   
```

### 15. **Найти все вхождения подстроки в строку**: 
Написать функцию, которая возвращает все вхождения подстроки в строку.

```
function findOccurrences(str, subStr) {   
	let occurrences = [];   
	let i = -1;   
	while ((i = str.indexOf(subStr, i+1)) != -1){     
		occurrences.push(i);   
	}   
	return occurrences; 
}
```

### 16. **Создание массива уникальных значений из двух массивов**: 
Написать функцию, которая объединяет два массива в один массив уникальных значений.

```
function uniteUnique(arr1, arr2) {   
	return [...new Set([...arr1, ...arr2])]; 
}
```

Эта функция использует оператор расширения для объединения двух массивов в один, затем преобразует получившийся массив в Set для удаления дубликатов и возвращает его в виде массива.

### 17. **Подсчет количества вхождений каждого слова в строке**: 
Написать функцию, которая подсчитывает количество вхождений каждого слова в строке.

```
function wordCount(str) {   
	let counts = {};   
	let words = str.split(' ');   
	words.forEach(function(word) {     
		if (counts[word]) {       
			counts[word]++;     
		} else {       
		counts[word] = 1;     
	}   });   
	return counts; 
}
```

Функция разбивает строку на слова и для каждого слова увеличивает его счетчик в объекте `counts`.

### 18. **Удаление определенного элемента из массива**: 
Написать функцию, которая удаляет все вхождения определенного значения из массива.

jsCopy code

`function removeElement(arr, value) {   return arr.filter(item => item !== value); }`

Функция использует метод `filter` для создания нового массива, включающего все элементы, которые не равны заданному значению.

### 19. **Рекурсивная функция для вычисления степени числа**: 
Написать функцию, которая вычисляет степень числа.

jsCopy code

`function power(base, exponent) {   if (exponent === 0) {     return 1;   } else {     return base * power(base, exponent - 1);   } }`

Это рекурсивная функция, которая умножает основание на результат функции `power` с уменьшенным на 1 показателем, до тех пор, пока показатель не станет равным 0.

### 20. **Перестановки строки**: Написать функцию, которая возвращает все возможные перестановки строки.

jsCopy code

`function getPermutations(string) {   if (string.length <= 1) {     return [string];   }   let permutations = [];   let substring = string.slice(1);   let previousPermutations = getPermutations(substring);    previousPermutations.forEach(permutation => {     for (let i = 0; i <= permutation.length; i++) {       let newPermutation = permutation.slice(0, i) + string[0] + permutation.slice(i);       permutations.push(newPermutation);     }   });   return permutations; }`

Это рекурсивная функция, которая использует подход "разделяй и властвуй", чтобы создать все возможные перестановки строки. Она создает новые перестановки, вставляя первый символ строки на каждую позицию всех перестановок оставшейся строки.