# Массив
Массив это упорядоченная структура данных. Мы не можем вставить в массив посередине какое-либо свойство. Можно добавить новое значение в начало, либо в конец.

Массив можно объявить двумя споcобами:

	let arr = new Array();
	let arr = [];
	
Элементы массива нумеруются, начиная с нуля.
Мы можем получить элемент, указав его номер в квадратных скобках.

	console.log(fruits[0]) //Apples
	
Вывести массив можно с помщью `alert`
	
Методы, работающие с концом массива (выполняются быстро):

	pop() - удаляет последний элемент массива
	fruits.pop() // Appeles Oranges Grape 10
	
	push - добавляет элемент в конец массива
	fruits.push("Pineapple") // Appeles Oranges Grape 10 Pineapple

Методы, работающие с началом массива (выполняются медленно из-за смещения массива):

	shift() - удаляет первый элемент массива, со сдвигом всех элементов
	fruits.shift() // Oranges Grape 10 Pineapple
	
	unshift - добавляет первый элемент массива
	fruits.unshift('Cherry') // Cherry Oranges Grape 10 Pineapple
	
Массив - это особый подвид объекта. Квадратные скобки, используемые для того чтобы получить доступ к свойству arr[0] - это по сути обычный синтаксис доступа к ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа- числовой индекс.

Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных, а так же свойство** lenght**, но в основе всё равно лежит объект.

Следует помнить, что в JS есть 8 основных типов данных. Массив является объектом и следовательно ведёт себя как объект, например копируется по ссылке: 

	let fruits = ['Apple']
	let clone = fruits
	console.log(fruits === arr) // true
	arr.push('Orange')
	console.log(fruits) // Apple Orange
		
В Js массивы очень оптимизированные благодаря внутреннему представлению, а именно - движок Js старается хранить элементы массивав непрерывной области памяти, один за другим. Но оптимизация пропадёт, если мы начнём использовать его как обычный объект:

	let arr = []
	arr[10] = 5
	arr.num = 55
	console.log(arr) // [ <10 empty items>, 5, num: 55 ]
Движок поймёт, что мы работаем с массивом как с объектом и способы оптимизации пропадут.

Варианты непривильного использования массива:
	
	Добавление нечисловогосвоства - arr.num = 55
	Создание дыр - arr[10] = 5
	Заполнение массива в обратном порядке, например: arr[10], arr[9]
	
По этому с массивом стоит работать, как с **упорядоченной структурой данных** Для этого массивы предоставляют специальные методы. 

### Перебор массива
Одним из старых способов перебора массива является цикл** for** по цифровым индексам: 

	let arr = ['Apple', 'Orange', 'Grape']
	
	for (let i = 0; i < arr.length; i++) {
		console.log(arr[i]) //Apple Orange Grape
	}
Так же есть цикл **for..of** 
	
	for (let key of(или in) arr) {
		console.log(arr[key]) //Apple Orange Grape
	}

### new Array()
Существует ещё один вариант синтаксиса для создания массива:
		
	let arr = new Aray('Apple' 'Orange', 'Grape')
Он редко применяется и кроме того, у него есть особенность, а именно - 
если **new Array()** вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.

	let arr = new Array(10)  
	console.log(arr.length) // 10
Все элементы в массиве будут пусты** (undefined)** при такой записи. Мы можем присвоить любому ключу в массиве любое значение и длинна массива не увеличится (конечно, если мы будем присваивать ключи до 10).

Массивы могут содержать не толькочисла и строки, но и другие массивы.
Массив так же можно привести к строке, методом **toString()** - 

	let arr = [1,2,3]
	console.log(String(arr)) //1,2,3

Так же есть способы 

	alert( [] + 1 ); // "1" 
	alert( [1] + 1 ); // "11" 
	alert( [1,2] + 1 ); // "1,21"
	
### Методы массивов
Массив, как и его элемент можно удалить с помощью ключевого слова **`delete()`**

	arr = ['Apple', 'Orange', 'Grape']  
	delete arr[0]  
	console.log(arr) //[ <1 empty item>, 'Orange', 'Grape' ]  
	delete arr  
	console.log(arr) //ReferenceError: arr is not defined
Для того чтобы массив сместился, нужно использовать мотод splice(), который умеет заменять, добавлять и удалять элементы.
	
Удаление:

	arr.splice(index[, deleteCount, elem1, ..., elemN])
	arr = ['Apple', 'Orange', 'Grape']
	arr.splice(1, 1);
	console.log(arr) // arr = ['Apple', 'Grape']

Так же, при удалении можно заменять элементы:

	arr = ['Apple', 'Grape']
	removed = arr.splice(0, 1, 'Pineapple', 'Lemon')
	console.log(arr) //[ 'Pineapple', 'Lemon', 'Grape' ]
	console.log(removed) // Apple

# Объекты
## Преобразование объектов в примитивы 
Если мы попытаемся сложить объекты, либо вычесть их, либо вывести с помощью 

	alert()
в этом случае, объект преобразется в строку, а затем выполнится операция.
1. Все объекты являются true, существуют только численные и строковые преобразования.
2. Численные преобразования происходят, когда мы вычитаем объекты или производим с ними математические операции. Например объекты Date могут вычитаться и результатом вычисления будет временной отрезок.
3. Строковое преобразование происходит, когда мы выводимм объект 

		alert(obj)

Так же существует 3 метода (хинта) преобразования в примитивы:
1. **`"string"`**

## Map и Set
`Map` - это коллекция ключ/значение, как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа.
	Методы и свойства:
	
- `new Map()` – создаёт коллекцию.
- `map.set(key, value)` – записывает по ключу `key` значение 	  `value`.
- `map.get(key)` – возвращает значение по ключу или  `undefined`, если ключ `key` отсутствует.
- `map.has(key)` – возвращает `true`, если ключ `key`                присутствует в коллекции, иначе `false`.
- `map.delete(key)` – удаляет элемент по ключу `key`.
- `map.clear()` – очищает коллекцию от всех элементов.
- `map.size` – возвращает текущее количество элементов.


		let map = new Map();  

		map.set("1", "str1");    // строка в качестве ключа  
		map.set(1, "num1");      // цифра как ключ  
		map.set(true, "bool1");  // булево значение как ключ  

		// помните, обычный объект Object приводит ключи к строкам?  
		// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:  
		console.log(map.get(1)); // "num1"  
		console.log(map.get("1")); // "str1"  
		console.log(map.size); // 3

**Map может использовать объекты вместо ключей**
Например:

	let user = { name: 'John' }  
	let myMap = new Map();  

	myMap.set(user, 123)  
	console.log(myMap.get(user)) // 123

Использование объектов в качестве ключей - одна из известных и частоприминяемых возможностей объекта `Map`. При строковых ключах обычный `Object` может подойти, но для ключей объектов - уже нет.

Попробуем заменить `Map` на `Object` в примере выше:

	let user = { name: 'John' }  
	let myMap = {};  

	myMap[user] = 123  
	console.log(myMap["[object Object]"]) // 123
	
Объект `Map` сравнивает ключи через `===`, с той лишь разницей, что `NaN` считается равным `NaN`. Так что `NaN` так же может использоваться в качестве ключа.
Каждый вызов `map.set` возвращает объект `map`, так что мы можем объеденить вызовы в цепочку.

			map.set('1', 'str1')
				  .set(1, 'num')
				  .set(true, 'bool1')
				  
### Перебор Map
Для перебора коллекции `Map` есть 3 меода:

-   `map.keys()` – возвращает итерируемый объект по ключам,
-   `map.values()` – возвращает итерируемый объект по значениям,
-   `map.entries()` – возвращает итерируемый объект по парам вида `[ключ, значение]`, этот вариант используется по умолчанию в `for..of`.

		let vegetables = new Map([  
			['огурцы', 250],  
			['помидоры', 200],  
			['кабачки', 220],  
		])  
		for (let vegetable of vegetables.keys()) {  
			console.log(vegetable) // огурцы помидоры кабачки  
		}  
		for (let vegetable of vegetables.values()) {  
			console.log(vegetable) // 250 200 220  
		}  
		for (let vegetable of vegetables.entries()) {  
			console.log(vegetable) // [ 'огурцы', 250 ] [ 'помидоры', 200] [ 'кабачки', 220 ]  
		}

**В отличии от `Object`, в `Map` перебор происходит в том же порядке, в каком происходило добавление элементов.**

Кроме этого, Map имеет встроенный метод **forEach**, схожий со встроенным методом массивов **Array**

	vegetables.forEach((value, key, map) => {  
		console.log(\`${key}: ${value} p.\`) // огурцы: 250 p. помидоры: 200 p. кабачки: 220 p.
	})

### Object.entries: Map из Object
При создании `Map` мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь:

	// массив пар [ключ, значение]  
	let map = new Map([  
		['1',  'str1'],  
		[1,    'num1'],  
		[true, 'bool1']  
	]);  

	alert( map.get('1') ); // str1
	
Если у нас уже есть обычный объект, и мы хотели бы создать `Map` из него, то поможет встроенный метод `Object.entries(obj)`, который получает объект и возвращает массив пар ключ-значение для него, как раз в этом формате.

Так что мы можем создать `Map` из обычного объекта следующим образом:

	let obj = {  
		name: "John",  
		age: 30  
	};  
	let map = new Map(Object.entries(obj));
	
### Object.fromEntries: Object из Map
Данный метод действует противоположно предыдущему - получив массив пар вида `[ключ, значение]`, он создаёт из них объект:

	let prices = Object.fromEntries(\[  
		['banana', 1],  
		['orange', 2],  
		['meat', 4]  
	]);  
	// now prices = { banana: 1, orange: 2, meat: 4 }  
	alert(prices.orange); // 2	
Мы можем использовать `Object.fromEntries`, чтобы получить обычный объект из `Map`.
К примеру у нас данный в `Map`, но их надо передать в сторонний код, который ожидает обычный объект.
Вот как это сделать:

	let map = new Map()  
	map.set('banana', 1)  
	map.set('orange', 2)  
	map.set('apple', 3)  

	let obj = Object.fromEntries(map.entries())  
	console.log(obj) // { banana: 1, orange: 2, apple: 3 }
	
Вызов `map.entries()` возвращает массив пар ключ/значение, как раз в нужном формате для `Object.fromEntries`.

Мы могли бы написать строку `(*)` ещё короче:

`let obj = Object.fromEntries(map); // убрать .entries()`

Это то же самое, так как `Object.fromEntries` ожидает перебираемый объект в качестве аргумента, не обязательно массив. А перебор `map` как раз возвращает пары ключ/значение, так же, как и `map.entries()`. Так что в итоге у нас будет обычный объект с теми же ключами/значениями, что и в `map`.

### Set
Объект `Set` - это особый вид коллекции: "множество" значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

-   `new Set(iterable)` – создаёт `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый `Set`.
-   `set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
-   `set.delete(value)` – удаляет значение, возвращает `true`, если `value` было в множестве на момент вызова, иначе `false`.
-   `set.has(value)` – возвращает `true`, если значение присутствует в множестве, иначе `false`.
-   `set.clear()` – удаляет все имеющиеся значения.
-   `set.size` – возвращает количество элементов в множестве.

При повторном вызове вызове `set.add()` c одним и тем же значением ничего не происходит, а за счёт этого и получается, что каждое значение появляется один раз.

Например мне надо чтобы в списке поситителей не было повторений, для этого я использую данный метод:

	let John = { name: 'John' }  
	let Pete = { name: 'Pete' }  
	let Mary = { name: 'Mary' }  
	let set = new Set()  
	
	set.add(John)  
	set.add(John)  
	set.add(Pete)  
	set.add(Pete)  
	set.add(Mary)  
	set.add(Mary)  
	for (let guest of set) {  
		console.log(guest.name) // John Pete Mary  
	}
	
Заметим забавную вещь. Функция в `forEach` у `Set` имеет 3 аргумента: значение `value`, потом _снова то же самое значение_ `valueAgain`, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом `Map`, в котором колбэк `forEach` имеет 3 аргумента. Выглядит немного странно, но в некоторых случаях может помочь легко заменить `Map` на `Set` и наоборот.

`Set` имеет те же встроенные методы, что и `Map`:

-   `set.values()` – возвращает перебираемый объект для значений,
-   `set.keys()` – то же самое, что и `set.values()`, присутствует для обратной совместимости с `Map`,
-   `set.entries()` – возвращает перебираемый объект для пар вида `[значение, значение]`, присутствует для обратной совместимости с `Map`.

### Перебор объекта Set
Можно перебрать содержимое объекта `set` как с помощью метода `for of`, так и с помощью `forEach`:

	let fruits = new Set(['apples', 'oranges', 'bananas'])  
	for(let fruit of fruits) console.log(fruit) // apples oranges bananas  

	fruits.forEach((fruit1, fruit2, fruits) => {  
		console.log(fruit1) // apples oranges bananas  
	})

## WeakMap и WeakSet
`WeakMap` первое отличие от `Map` в том, что ключи `WeakMap` должны быть объектами, а не примитивными значениями:

	let weakMap = new WeakMap();  
	let obj = {}  
	weakMap.set(obj, 'Объект')
Теперь, если сы используем оббъект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти и из объекта `WeakMap` автоматически

	

# Символы
Представляют из себя уникальные идентификторы, создаются с помощью ключевого слова **Symbol()**.

Для объекта в качестве ключей могут использоваться только строки или символы. Ни числа, ни логические значения не подходят.

	let id = Symbol("id")

Символ созданный однажды абсолютно уникален.

	let id1 \= Symbol("id");  
	let id2 \= Symbol("id");  
	console.log(id1 \== id2); // false

При выводе чего-либо с помощью [[**alert**]], выводимый тип данных приводится к строке. В случае же с **Symbol**, этого не происходит и выводится **ошибка** в консоль:

	let id \= Symbol("id"); 
	alert(id); // TypeError: Cannot convert a Symbol value to a string

Это "языковая защита" от путаницы. Если действительно понадобится вывести символ, то необходимо явно привести его к строке методом [[**.toString()**]] 

# Числа
В современном Js есть 2 типа чисел, это - обычные числа с плавающей запятой - **Number**
И второй - это** BigInt** - дают возможность работать с целочисленными значениями от -2 в 53 степени, до 2 в 53 степени.

## Способы записи числа
Если нам необходимо записать большое число с повторяющимися нулями, мы можем использовать букву **e** для того чтобы упростить запись числа 

	let billion = 1000000000  
	let billion1 = 1e9  
	console.log(billion === billion1) // true

Для того чтобы записать нули слева от числа - нужно использовать минус (-)

	let ms = 0.000001;  
	let ms1 = 1e-6;  
	console.log(ms === ms1) //true

## Округление
В Js есть несколько встроенных функций для работы с округлением:
	
### Math.floor
Округление в меньшую сторону: 3.1 станет 3, а -1.1 станет -2

### Math.ceil 
Округление в большую сторону: 3.1 становится 4, а -1.1 становится -1

### Math.round 
Округление до ближайшего целого: 3.1 станет 3, 3.6 станет 4, а -1.1 станет 1.

### Math.trunc
**Не поддерживается в IE** Удаляет дробную часть без округления: 3.1 станет 3, а -1.1 станет 1.

###  toFixed(n)
Округляет число до n знаков после запятой и возвращает его строковое представление:
		
	let num = 111.23456
	console.log(num.toFixed(2)) //111,23
Метод работает как Math.round, а именно - округляет до ближайшего целого числа. Если десятичная часть короче, то метод добавит нули в конце строки.

## Другие математические функции
### Math.random()
Возвращает случайное число в диапозоне от 0 до 1

	alert( Math.random() ); // 0.1234567894322 
	alert( Math.random() ); // 0.5435252343232 
	alert( Math.random() ); // ... (любое количество псевдослучайных чисел)
	
### Math.max(a, b, c...)` / `Math.min(a, b, c...)
Возвращает наибольшее/наиментшее число из перечисленных аргументов.
	
	alert( Math.max(3, 5, -10, 0, 1) ); // 5 
	alert( Math.min(1, 2) ); // 1
	
### Math.pow(n, power)
Возвращает число `n`, возведённое в степень `power`

	alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024


## Неточные вычисления
Если число слишком большое, то оно переполнит 64-битное хранилище и вернёт Infinity

	console.log(1e500) //Infinity
	
В Js есть одна особенность с дробными вычислениями, а именно - их неточность. Допустим нам надо сложить два дробных числа 

	console.log(0.1 + 0.3) // 0.30000000000000004
	
Так происходит из-за вычислений Js. Что такое 0.1? Это 1/10, а что такое 0.3? Это 1/3. Если 1/3, то мы получим 0,3333333333333333.
По этому, когда Js пытается представить 0.3, то получается такое длинное представление дробного числа.
По этому, когда нам предстоит работа с дробными числами, стоит использовать метод** toFixed(n)**

	let sum = .1 + .2  
	console.log(sum.toFixed(1)) // 0.3
	
	
## Проверка: isFinite и isNan
1. Infinity - бесконечность.
2. NaN - числовая ошибка.

Оба данных представления пренадлежат типу **number** и они не являются обычнми числами, по этому есть две функции для их проверки:
	
### isNan(value)
Преобразует значение в числои проверяет является ли оно NaN
	
	console.log( isNaN(NaN) ); // true  
	console.log( isNaN(11) ); // false  
	console.log( isNaN("str") ); // true
Этот метод нам нужен по тому что мы не можем просто сравнить **NaN**, т.к. данное значения является уникальным и оно не равно даже самому себе.

### isFinity(value) 
Преобразует аргумент в число и возвращает true, если оно является обычнм числом, т.е. не Nan/Infinity/-Infinity
	
	console.log( isFinite("15") ); // true 
	console.log( isFinite("str") ); // false, потому что специальное значение: NaN 
	console.log( isFinite(Infinity) ); // false, потому что специальное значение: Infinity

Т.е. данный метод можнно использовать для проверки числа в строке.
	
	let num = +prompt("Enter a number", ''); // вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число alert( isFinite(num) );
	

## Преобразование
можно осуществить путём добавления к строке + или использовать метод Number(). Если строка не является в точностичислом, то результат будет NaN:

	console.log(+"100px")// NaN

Для того чтобы получить числовое значение нужно использовать parseInt() и parseFloat().

### parseInt()
Возвращает целое число

	alert( parseInt('100px') ); // 100
	alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
	
### parseFloat()
Возвращает число c плавающей запятой

	alert( parseFloat('12.5em') ); // 12.5
	alert( parseInt('12.3') ); // 12, вернётся только целая часть alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
	

# Строки
Одинарные '' или  двойные "" - однострочные, а обрытные (` `) многострочные.

## Спец символы
Многострочные строки также можно создавать с помощью одинарных и двойных ковычек, используя «символ перевода строки» - `\n`

	let guestList = "Guests:\n * John\n * Pete\n * Mary";
	
## Доступ к символам 
Получить символ в строке можно с помощью квадратных скобок и индекса, прямо как в массиве, либо использовать метод `charAt(0)` 

	let string = 'Hello World';  
	console.log(string[0]) //H  
	console.log(string.charAt(1)) //e
	
Разница в этих способах лишь в том, что если `[ ]` вернёт `undefined`, если не найдёт символ, а `charAt` - пустую строку

Так же вывести строку посимвольно можно с помщью цикла `**for of**`
	
	for (let char of 'Hello') {  
    	console.log(char)  
	}
	
## Строку нельзя изменить
Нельзя взять символ из строки и заменить его на другой. 

	let str = 'Hello'  
	str[0] = 'Q'  
	console.log(str) // Hello

## Изменить регистр
Можно с помощью методов 

	toLowerCase()
	toUpperCase()
	
Так же можно изменить регистр отдельной буквы в слове
		
		let str = 'Hello'  
		console.log(str[0].toLowerCase()) // h
	
## Поиск подстроки
Есть несколько способов поиска подстроки

	str.indexOf(substr, pos)
Ищет подстроку `**substr**` в строке, начиная с позиции `**pos**` и возвращает позицию на которой распологается совпадение, либр `**-1**` при отсутствии совпадения. 

	let str = 'Hello beautiful world '  
	console.log(str.indexOf('Hello')) // 0
	//возращает -1, если не находит позицию
	console.log(str.indexOf('hello')) // -1  
	console.log(str.indexOf('beautiful')) // 6  
	console.log(str.indexOf('world')) // 16

В данном примере метод отсчитывает от начала строки - сколько символов до определённогослова и возвращает их количество.
У метода так же есть второй необязательный аргумент, позволяющий начать с определённой позиции.
Например, первое вхождение `"id"` — на позиции `1`. Для того, чтобы найти следующее, начнём поиск с позиции `2`

	let str = 'Widget with id'  
	console.log(str.indexOf('id', 1)) // 1  
	console.log(str.indexOf('id', 2)) // 12
	
Чтобы найти все вхождения подстроки, нужно запустить **`indexOf`** в `цикле`

	let str = 'Ослик Иа-Иа посмотрел на виадук';  
	let target = 'Иа'; // цель поиска  
	let pos = 0;  
  
	while (true) {  
		let foundPos = str.indexOf(target, pos)  
		if (foundPos === -1) { break }  

		console.log(`Найдено тут: ${foundPos}`);  
		pos = foundPos + 1 // продолжаем со следующей позиции  
	}  
	//Найдено тут: 6  
	//Найдено тут: 9

### str.includes(substr, pos)
Возвращает `true`, если в строке есть подстрока `substr`, либо `false` если нет.

	let str \= "Ослик Иа-Иа посмотрел на виадук";  
	console.log(str.includes('посмотрел')) // true  
	// Необязательный атрибут позволяет начать поиск с определённой позиции:  
	console.log(str.includes('посмотрел', 111)) //false

### startsWitch, endsWith
Данные методы проверяют, начинается ли или заканчивается строка определённой строкой и возвращает `true` или `false`:

	console.log(str.startsWith('Ослик'))  // true  
	console.log(str.startsWith('О')) 	 // true  
	console.log(str.endsWith('виадук'))  // true  
	console.log(str.endsWith('ук'))		// true

### Получение подстроки
В `Js` есть `3` метода получения подстроки:
	1. `slice`
	2.`substring`
	3. `substr`
	
	let str = 'Шла Саша по шоссе и сосала сушку...'  
	console.log(str.slice(0, 15)) // Шла Саша по шос...
Если не указать явный конец строки, то метод отработает до конца строки.
Так же, начало и конец можно указывать отрицательными значениями.

	`str.substring(start [,end])`
Почти тоже самое что и `**slice**`, но можно задавать `**start**` больше, чем `**end**` 

	let str \= "stringify";  
	// для substring эти два примера — одинаковы  
	console.log( str.substring(2, 6) ); // "ring"  
	console.log( str.substring(6, 2) ); // "ring"  
	// …но не для slice:  
	console.log( str.slice(2, 6) ); // "ring" (то же самое)  
	console.log( str.slice(6, 2) ); // "" (пустая строка)

## Сравнение строк
### str.codePointAt(pos)
возращает код символа
		
		console.log('a'.codePointAt(0)) // 197
		
### String.fromCodePoint(code)
Создаёт символ по его коду
		
		console.log(String.fromCodePoint(90)) // Z
Создание строки с алфавитом и символами:

		let str = '';
		
		for (let i = 65; i <= 220; i++) {
			str += String.fromCodePoint(i);
		}
		console.log(str) // ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂

# Деструктурирующее присваивание
В `Js` есть две чаще всего используемые структуры данных - это `Object` и `Array`.
`Объекты` позволяют нам создавать одну сущность, которая хранит элементы данных по `ключам`, а `массивы` - хранить `упорядоченные коллекции данных`.
Но когда мы `передаём` их в `функцию`, то ей может понадобится не` объект/массив` целиком, а `отдельные элементы`.
`Деструктурирующее присваивание` - это специальный синтаксис, который позволяет нам `"распоковать"` `массивы` или `объекты` в кучу переменных, так как иногда они более удобны.
`Деструктуризация` также прекрасно работает со сложными `функциями`.
Пример `деструктуризации` массива:

	let arr = ["John", "Doe"]  
	let [firstName, surName] = arr  
	console.log(firstName) // John  
	console.log(surName) // Doe
	
**`Деструктуризация` не означает "`разрушение`"**
`Деструктурирующее присваивание` не униктожает `массив`. Оно вообще ничего не делает с правой частью присваивания, его `задача` - только `скопировать` нужные `значения в переменные`.
Это просто коротний вариант записи:
	
	// let [firstName, lastName] = arr
	let firstName = arr[0]
	let lastName = arr[1]
	
`Пропустить` элементы `массива` в `короткой записи` можно с помощью `запятых`: 
	
	// второй элемент не нужен 
	let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"]; 
	console.log( title ); // Consul
	
Можно использовать любой перебираемый объект, не только массивы: 

	let [one, two, three] = new Set([1, 2, 3]);  
	console.log(one, two, three) // 1 2 3
	
### Деструктуризация объекта
Синтаксис:

	let {var1, var2} = {var1:…, var2:…}
	
Пример:

	let options = {  
		title: 'Меню',  
		width: 100,  
		height: 200,  
	}  
	let {title, width, height} = options  
	console.log(title) // Меню  
	console.log(width) // 100  
	console.log(height) // 200 
	
Или:

	let {height, width, title} = { title: "Menu", height: 200, width: 100 }  
	console.log(title) // Меню  
	console.log(width) // 100  
	console.log(height) // 200
	
Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполняются, если значения отсутсвуют.

	let options = { title: "Menu" };
	let {width = prompt("width?"), title = prompt("title?")} = options; console.log(title); // Menu 
	console.log(width); // (результат prompt)
	
Так же можно совмешать `:` и `=`

	let options = { title: "Menu" };
	let {width: w = 100, height: h = 200, title} = options; 
	alert(title); // Menu 
			alert(w); // 100 
			alert(h); // 200
Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно:

	let options = { title: "Menu", width: 100, height: 200 }; 
	// взять только title, игнорировать остальное 
	let { title } = options; 
	alert(title); // Menu
	
# Json.stringify
`Java Script Object Notation`- общий формат для представления значений и объектов. Первоночально он был создан для `Js`, но многие языки так же имеют библиотеки, которые могут работать с ним. Таким образом, `JSON` легко использовать для обмена данными, когда клиент использует `Js`, а сервер написан на `Riby/PHP/Java` или любом другом языке.

`JSON` имеет методы:
-   `JSON.stringify` для преобразования объектов в JSON.
-   `JSON.parse` для преобразования JSON обратно в объект.

В примере ниже происходит преобразование объекта в строку с помозью метода `JSON.stringify`:

	let student = { 
		name: 'John', 
		age: 30, 
		isAdmin: false, 
		courses: ['html', 'css', 'js'], 
		wife: null 
	}; 
		let json = JSON.stringify(student); 
	console.log(json) // {"name":"John","age":30,"isAdmin":false,"courses":["html","css","js"],"wife":null}
	console.log(typeof json); //string

`JSON.stringify` может быть применён к примитивам.
JSON поддерживает следующие типы данных:
-   Объекты `{ ... }`
-   Массивы `[ ... ]`
-   Примитивы:
    -   строки,
    -   числа,
    -   логические значения `true/false`,
    -   `null`.
Например:

	// число в JSON остаётся числом 
	console.log( JSON.stringify(1) ) // 1 
	
	// строка в JSON по-прежнему остаётся строкой, но в двойных кавычках 
	console.log( JSON.stringify('test') ) // "test"
	
	console.log( JSON.stringify(true) ); // true 
	console.log( JSON.stringify([1, 2, 3]) ); // [1,2,3]