## Адаптивная и отзывчивая веб-разработка?
Адаптивная и отзывчивая (responsive) веб-разработка - это подходы к созданию сайтов, которые обеспечивают оптимальное взаимодействие и просмотр для пользователей независимо от используемого устройства (настольного компьютера, мобильного телефона, планшета и т.д.). Вот некоторые методы и практики, которые я применяю в своей работе:

1. **Mobile First:** Этот подход предполагает разработку дизайна и функциональности сначала для мобильных устройств, а затем масштабирование и адаптацию его для больших экранов. Это помогает обеспечить хорошую производительность на мобильных устройствах и фокусироваться на наиболее важных функциях.
2. **Использование CSS Media Queries:** С помощью медиа запросов CSS мы можем применять разные стили для разных размеров экрана и устройств. Это позволяет нам адаптировать наш веб-сайт или приложение для разных разрешений экрана и ориентаций.
3. **Резиновая сетка (Flexible Grids):** Использование резиновых сеток позволяет элементам интерфейса масштабироваться и адаптироваться в зависимости от размера экрана.
4. **Гибкие изображения (Flexible Images):** Изображения и медиа-контент должны быть адаптированы под разные размеры экрана, чтобы они корректно отображались и не создавали проблем с переполнением контента.
5. **Использование CSS Flexbox и CSS Grid:** Эти две технологии CSS существенно упрощают создание отзывчивых макетов и дают нам большую гибкость при разработке дизайна.
6. **Тестирование на различных устройствах:** Важно регулярно проводить тестирование на различных устройствах и размерах экрана, чтобы убедиться, что ваш сайт или приложение отображается корректно в различных условиях.
7. **Понимание важности производительности:** На мобильных устройствах, особенно в регионах с медленным интернетом, очень важно управлять размером и производительностью вашего сайта или веб-приложения.
8. **Progressive Enhancement:** (прогрессивное улучшение) - это подход к веб-разработке, который ставит основные функции и доступность на первое место.

Сначала создается минимальная версия веб-страницы, которая работает на любом устройстве и в любом браузере, сосредотачиваясь на базовом функционале и контенте. Затем, по мере возможностей браузера или устройства пользователя, добавляются дополнительные уровни функциональности и улучшений.

Примеры таких улучшений могут включать:

1. Повышенную стилизацию с использованием CSS для браузеров, которые это поддерживают.
2. Дополнительный функционал на JavaScript для браузеров, которые могут его обрабатывать.
3. Использование современных API, таких как Service Workers для оффлайн-функциональности, но только для браузеров, которые поддерживают эти технологии.

Основная цель прогрессивного улучшения - обеспечить базовый опыт для всех, улучшая его там, где это возможно, вместо предположения о том, что все пользователи имеют доступ к последним технологиям и функциям.

Прогрессивное улучшение помогает обеспечить доступность и устойчивость веб-сайтов и веб-приложений в широком спектре условий и контекстов, гарантируя, что все пользователи имеют доступ к базовому контенту и функциональности.
***
## Сетевые технологии
Сетевые технологии - это методы, технологии и протоколы, которые используются для связи между компьютерами и другими устройствами в сети. Интернет, например, основан на наборе таких технологий.

## **1. Топология сети:**
Это структура или форма сети (граф). Тип топологии сети может варьироваться от простых, например, звезда или шина, до более сложных, таких как дерево или смешанная топология.
	1. **Шина (Bus topology):** В этой топологии все устройства (или узлы) подключены к общей шине. Данные от отправителя к получателю передаются по этой общей шине. Преимуществом является простота настройки, недостатком - низкая надежность и масштабируемость.
	2. **Звезда (Star topology):** Все устройства подключены к центральному устройству или узлу, обычно называемому хабом или коммутатором. Вся коммуникация проходит через этот центральный узел. Это увеличивает надежность, но делает центральное устройство узким местом.
	3. **Кольцо (Ring topology):** Устройства подключены таким образом, что образуют кольцо, и информация передается от устройства к устройству в одном направлении. Это может быть эффективным решением, но проблемы могут возникнуть, если одно из устройств выходит из строя.
	4. **Дерево (Tree topology):** Это вариация звездной топологии, где звезды связаны вместе в иерархическую структуру. Часто используется в сетях с большим количеством устройств.
	5. **Сеть (Mesh topology):** В этой топологии каждое устройство подключено к каждому другому устройству в сети. Это обеспечивает очень высокую надежность, но может быть дорогостоящим и сложным в обслуживании.
	6. **Гибридная (Hybrid topology):** Гибридная топология сочетает две или более разных топологий для создания сети, которая наилучшим образом соответствует потребностям организации.
Важно отметить, что выбор топологии может зависеть от многих факторов, включая стоимость, простоту установки и обслуживания, а также требования к надежности и производительности.

### **2. Протоколы сетевого уровня:**
Протоколы сетевого уровня управляют тем, как данные передаются по сети. Они определяют методы для идентификации машин, маршрутизации и передачи данных от источника к месту назначения. Самым известным протоколом сетевого уровня является IP (Internet Protocol), но существуют и другие.

**1. Internet Protocol (IP):**
IP отвечает за маршрутизацию и передачу данных от источника к месту назначения в интернете. Он делает это, разделяя данные на пакеты и маркируя их IP-адресами отправителя и получателя.
- _IPv4:_ Это четвертая версия IP, и на данный момент она является наиболее широко используемой. Однако она стала истощаться из-за ограниченного количества уникальных адресов (около 4,3 миллиарда).
- _IPv6:_ Это более новая версия протокола IP, разработанная для решения проблемы исчерпания адресов IPv4. Она предоставляет огромное количество уникальных адресов (около 340 секстильонов), что делает ее гораздо более масштабируемой.
**2. Internet Control Message Protocol (ICMP):**
ICMP используется вместе с IP для предоставления обратной связи об ошибках в окружении сетевой связи. Он также используется для диагностики и отладки в сетевых утилитах, таких как "ping" и "traceroute".
**3. Address Resolution Protocol (ARP):**
ARP используется для определения аппаратного (MAC) адреса устройства по его IP-адресу в локальных сетях.
**4. Routing Information Protocol (RIP):**
RIP - это один из протоколов маршрутизации, который помогает роутерам определять, какой путь лучше всего использовать для отправки пакетов. Это один из наиболее старых протоколов маршрутизации, и он сегодня редко используется.
**5. Open Shortest Path First (OSPF):**
OSPF - это более современный протокол маршрутизации, который также помогает роутерам определять оптимальный путь для передачи пакетов. Он работает лучше в больших сетях, чем RIP.

Это лишь некоторые из протоколов сетевого уровня. Более сложные и развитые сети могут использовать различные другие протоколы в зависимости от конкретных потребностей.

### **3. Протоколы транспортного уровня:**
Протоколы транспортного уровня обеспечивают надежное или ненадежное передвижение данных между двумя системами. Они управляют механизмами установления соединения, обработкой ошибок и контролем потока. Два основных протокола транспортного уровня в модели OSI (Open Systems Interconnection) - это TCP (Transmission Control Protocol) и UDP (User Datagram Protocol).

**1. Transmission Control Protocol (TCP):**
TCP является надежным протоколом, обеспечивающим установление соединения. Он использует механизмы проверки ошибок и контроля потока для гарантии доставки пакетов без ошибок и в правильном порядке. Это делает TCP идеальным для приложений, которым необходима надежная доставка, таких как веб-браузеры, электронная почта и файловые передачи.
TCP работает на основе установления соединения: прежде чем начать передачу данных, отправитель и получатель должны установить "сессию связи". Этот процесс включает в себя обмен пакетами управления для подготовки и синхронизации обоих концов соединения перед началом передачи данных.

**2. User Datagram Protocol (UDP):**
UDP, в отличие от TCP, является ненадежным протоколом, не обеспечивающим установление соединения. Он просто передает датаграммы от отправителя к получателю без гарантии доставки или сохранения порядка пакетов. Это делает UDP более быстрым и эффективным с точки зрения ресурсов, чем TCP, но менее надежным.
UDP идеально подходит для приложений, которым необходима скорость больше, чем надежность. Примеры включают в себя видео и аудио потоковое вещание, видео игры и некоторые виды VoIP (голос по IP).

**3. Stream Control Transmission Protocol (SCTP):**
SCTP - это еще один протокол транспортного уровня, который предлагает функции, сходные с TCP, но также обеспечивает некоторые улучшения, такие как многопоточность и улучшенную защиту от затопления и обрыва соединения. SCTP в основном используется в телекоммуникационных системах.
В зависимости от требований приложения разработчики могут выбрать протокол, который наилучшим образом подходит для их потребностей.

### **4. Протоколы прикладного уровня:**
Это протоколы, которые в основном видят пользователи. Примерами являются _HTTP (Hypertext Transfer Protocol)_ для веб-серфинга, _SMTP (Simple Mail Transfer Protocol)_ для отправки электронной почты, _FTP (File Transfer Protocol)_ для передачи файлов и _DNS (Domain Name System)_ для преобразования доменных имен в IP-адреса.

### **5. Оборудование для сетей:**
Важными компонентами сетевых технологий являются маршрутизаторы, коммутаторы и мосты, которые помогают контролировать поток данных по сети. Коммутаторы используются для соединения устройств в локальной сети, а маршрутизаторы направляют данные между различными сетями. Мосты, в свою очередь, используются для связи между сегментами одной и той же сети.
Сетевые технологии представляют собой сложную и интересную область, которая включает в себя множество различных компонентов и технологий, работающих вместе, чтобы обеспечить надежное и эффективное взаимодействие данных.
***
## Принципы работы браузера
Веб-браузер - это сложная программа, которая преобразует HTML, CSS и JavaScript, а также другие ресурсы, полученные из Интернета, в веб-страницы, которые вы можете просматривать на экране компьютера или мобильного устройства.

Вот подробно описанные этапы работы веб-браузера:

**1. Ввод URL (Uniform Resource Locator):**
Процесс начинается, когда вы вводите URL в адресную строку браузера. URL может быть веб-сайтом, например, [www.example.com](http://www.example.com/), или может быть конкретной веб-страницей, например, [www.example.com/page1](http://www.example.com/page1).
	".com" в адресе сайта называется доменом верхнего уровня (TLD - Top Level Domain). Это одна из частей доменного имени, которая следует сразу за основным именем домена.
	Вот несколько ключевых моментов о ".com":

1. **Происхождение**: Сокращение от "commercial", ".com" первоначально предназначался для коммерческих организаций. Однако из-за его популярности он стал широко использоваться для различных видов веб-сайтов, включая личные блоги, образовательные ресурсы и многое другое.
2. **Популярность**: ".com" является одним из самых популярных и широко используемых доменов верхнего уровня. Многие компании и бренды предпочитают регистрировать домен ".com" из-за его узнаваемости и авторитета.
3. **Регистрация**: Любой может зарегистрировать домен ".com" через аккредитованные регистраторы доменных имен. Нет особых ограничений или требований для регистрации домена с этим TLD.
4. **Другие TLD**: Кроме ".com" существует множество других доменов верхнего уровня, таких как ".org" (для организаций), ".net" (изначально для сетевых организаций), ".gov" (для правительственных органов), ".edu" (для образовательных учреждений) и многие другие, включая страновые коды (например, ".ru" для России, ".uk" для Великобритании).

**2. Запрос к DNS (Domain Name System):**
Веб-браузер обращается к DNS-серверу, чтобы перевести имя домена, введенное вами, в IP-адрес. IP-адрес нужен для установления соединения с сервером, на котором находится веб-сайт.

**3. Установление соединения:**
После получения IP-адреса браузер устанавливает соединение с веб-сервером. Это обычно делается с использованием протокола HTTP (Hypertext Transfer Protocol) или HTTPS (HTTP Secure), которые являются протоколами транспортного уровня.

**4. Запрос веб-страницы:**
Браузер посылает HTTP GET запрос к серверу, запрашивая веб-страницу, которую вы хотите посмотреть.

**5. Получение веб-страницы:**
Веб-сервер отвечает на запрос, отправляя файлы веб-страницы обратно в браузер. Эти файлы обычно включают HTML, CSS и JavaScript, а также могут включать другие типы медиа, такие как изображения и видео.

**6. Разбор и отображение веб-страницы:**
Браузер читает и интерпретирует HTML, CSS и JavaScript, чтобы построить веб-страницу. Это включает в себя построение DOM (Document Object Model), которое представляет структуру веб-страницы, применение CSS для стилизации элементов, и выполнение JavaScript для добавления интерактивности. Весь этот процесс называется "рендерингом" веб-страницы.

**7. Интерактивность и асинхронные запросы:**
После отображения веб-страницы браузер остается в активном состоянии, позволяя пользователю взаимодействовать со страницей и запуская любой JavaScript, который может изменить страницу в ответ на действия пользователя. Браузер также может делать асинхронные запросы к серверу для получения новых данных без перезагрузки всей страницы (это часто делается с использованием технологии AJAX).

Это примерная последовательность действий, которые происходят при использовании веб-браузера. Однако стоит отметить, что многие из этих шагов могут быть значительно более сложными, в зависимости от специфики веб-страницы и используемого браузера.
***
# Оптимизация картинок в проекте
### Сжатие изображений
1. **TinyPNG / TinyJPG**: Вручную сжимай изображения перед их загрузкой на сервер.
    - [Сайт TinyPNG](https://tinypng.com/)
2. **ImageMagick**: Если ты работаешь с сервером, можно настроить автоматическое сжатие.
    - [Документация ImageMagick](https://imagemagick.org/index.php)

### Ленивая загрузка (Lazy Loading)
1. **Vue-Lazyload**: Поскольку ты работаешь с Vue, этот плагин может пригодиться.
    - [GitHub репозиторий Vue-Lazyload](https://github.com/hilongjw/vue-lazyload)
2. **Native Lazy Loading**: В HTML5 есть атрибут `loading="lazy"`, который тоже делает задачу.

### Адаптивные изображения
1. **`<picture>` и `srcset`**: HTML5 предоставляет нативные методы для адаптивной загрузки изображений.
2. **Cloudinary**: Это облачный сервис, который может масштабировать и оптимизировать изображения на лету.
    - [Официальный сайт Cloudinary](https://cloudinary.com/)

### Векторные изображения
1. **SVG**: Вместо растровых изображений стоит использовать векторные, если возможно. Они масштабируются без потери качества.
### CSS Image Sprites
1. **Sprites**: Этот метод заключается в объединении многих маленьких изображений в одно большое. Уменьшает количество HTTP-запросов.

### WebP формат
1. **WebP**: Этот формат обычно обеспечивает лучшее сжатие, чем PNG или JPEG.
***
# Garbage Collector
В JavaScript используется автоматическое управление памятью, а сборщик мусора (Garbage Collector, GC) играет ключевую роль в этом процессе. В основном, GC в JavaScript работает на принципе "подсчета ссылок" и "алгоритма пометок".

### Подсчет ссылок
Этот метод прост: если на объект нет ссылки, его можно считать мусором и удалить. Однако этот подход имеет свои ограничения, например, он не может обрабатывать циклические ссылки.

### Алгоритм пометок (Mark-and-Sweep)
Этот алгоритм состоит из двух этапов:

1. **Mark (Пометка)**: Алгоритм проходит по всем живым объектам и помечает их.
2. **Sweep (Очистка)**: Все неотмеченные объекты удаляются.

### Как это работает
1. Время от времени сборщик мусора запускается.
2. Он идентифицирует "корневые" объекты: объекты в стеке вызовов, глобальные объекты и так далее.
3. Затем он ищет объекты, доступные из корневых, затем объекты, доступные из этих объектов и так далее, отмечая их как доступные.
4. Все неотмеченные объекты считаются мусором и удаляются.

### Проблемы
1. **Паузы в работе приложения**: GC может занять время, что может привести к заметным задержкам в работе приложения.
2. **Неопределенность**: Сложно предсказать, когда GC начнет свою работу.

### Оптимизации
JavaScript движки, такие как V8 (в Chrome и Node.js), используют оптимизации вроде "инкрементной" и "генерационной" сборки мусора, чтобы минимизировать влияние на производительность.

### Инкрементная сборка мусора
В классическом подходе "Mark-and-Sweep" всё происходит одновременно: помечание живых объектов и удаление мёртвых объектов. Это может вызвать заметные паузы в работе приложения, потому что весь код останавливается, пока сборщик мусора работает. Инкрементная сборка мусора решает эту проблему, разбивая задачу на меньшие части и выполняя их по частям, чередуя с выполнением другого кода. Это уменьшает задержки и делает работу приложения более плавной.

### Генерационная сборка мусора
Этот метод основан на предположении, что большинство объектов умирают молодыми, то есть становятся ненужными вскоре после создания. Поэтому память делится на два "поколения": молодое и старое. Сборка мусора чаще происходит в молодом поколении, что быстрее и эффективнее. Если объект "выживает" после нескольких циклов сборки мусора в молодом поколении, он "переезжает" в старое поколение, где сборка мусора происходит реже.

#### Комбинированный подход
Часто эти две оптимизации используются вместе для максимизации производительности. Например, V8, движок JavaScript в браузере Chrome, использует и инкрементную, и генерационную сборку мусора.
***
# CSRF (Cross-Site Request Forgery) - Подделка межсайтовых запросов
это вид атаки, при которой злоумышленник может выполнить нежелательные действия от имени аутентифицированного пользователя без его ведома. Эта атака происходит, когда пользователь, уже авторизирован на некотором сайте (например, веб-приложении), посещает другой сайт, который формирует запрос к первому сайту от имени пользователя.

### Пример
Представь, что ты авторизован в интернет-банке. Если бы этот банк не использовал механизмы защиты от CSRF, злоумышленник мог бы создать веб-страницу, которая отправляет запрос на перевод средств с твоего счёта на счёт злоумышленника. После этого, он мог бы отправить тебе ссылку на эту страницу по email или через социальные сети. Если бы ты открыл эту страницу, оставаясь при этом авторизованным в банке, перевод бы выполнен.

### Защита
Для защиты от CSRF-атак часто используются специальные токены. При каждом запросе к серверу вместе с данными отправляется и этот токен. Сервер проверяет токен и только после этого выполняет действие. Так как злоумышленник не знает значение этого токена, он не сможет успешно выполнить атаку.
Существуют и другие методы защиты: проверка заголовков запроса, использование куки с флагом `SameSite` и так далее.

### Токен
Токен для защиты от CSRF-атак может храниться в разных местах, и выбор зависит от конкретной архитектуры и требований к безопасности. Вот несколько распространенных вариантов:

#### 1. Cookies
Токен может быть сохранен в cookie. Однако, это может сделать систему уязвимой для атак через кражу cookies (если, например, не установлен флаг `HttpOnly`).
#### 2. Web Storage (localStorage, sessionStorage)
Хранение в Web Storage также возможно, но это не рекомендуется из-за потенциальной уязвимости для кражи токена через скрипты (например, при XSS-атаках).
#### 3. Внедрение в HTML
Токен можно внедрять непосредственно в HTML-страницу, которая генерируется на сервере. Это один из более безопасных вариантов, если страница загружается по HTTPS.
#### 4. Заголовки HTTP
Токен может передаваться в HTTP-заголовках при каждом AJAX-запросе.
#### 5. Meta-теги в HTML
Токен можно хранить в meta-тегах, откуда он затем считывается JavaScript и добавляется к каждому запросу.
#### 6. Redux/Vuex Store (для SPA)
В одностраничных приложениях (SPA) токен может храниться в глобальном состоянии приложения (например, в Vuex для Vue.js).

Как правило, для повышения безопасности комбинируют несколько методов. Например, хранят токен в HTTP-only cookie и дополнительно включают его в заголовки HTTP при выполнении запросов на сервер.

# Запросы с одного домена на другой
### 1. CORS (Cross-Origin Resource Sharing)
CORS — это механизм, позволяющий или запрещающий веб-ресурсам взаимодействовать с ресурсами другого домена. Это делается с помощью HTTP-заголовков. На сервере настраивается список доменов, которым разрешено обращаться к ресурсам.
```
const express = require('express');
const cors = require('cors');

const app = express();

const corsOptions = {
  origin: 'https://yourdomain.com', // замените на ваш домен
  optionsSuccessStatus: 204
};

app.use(cors(corsOptions));
```

### 2. JSONP (JSON with Padding)
JSONP — старый и потенциально небезопасный метод. Идея заключается в том, что `<script>` теги не ограничиваются политикой одного источника. Сервер возвращает не просто JSON, а JavaScript-код, который может быть выполнен в контексте страницы.
```
<script type="text/javascript">
  function fetchJsonp(url, callbackName) {
    var script = document.createElement('script');
    script.src = url + '?callback=' + callbackName;
    document.body.appendChild(script);
  }

  function handleData(data) {
    console.log(data);
  }

  fetchJsonp('https://otherdomain.com/data', 'handleData');
</script>
```
### 3. Proxy сервер
Вы можете настроить сервер таким образом, чтобы он принимал запросы от вашего домена и перенаправлял их на целевой сервер, обходя ограничения CORS.
```
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

app.use('/proxy', createProxyMiddleware({
  target: 'https://otherdomain.com',
  changeOrigin: true,
  pathRewrite: { '^/proxy': '' },
}));

app.listen(3000);
```
# XSS
XSS, или Cross-Site Scripting, — это вид атаки на веб-приложения, при которой злоумышленник может внедрить произвольный JavaScript-код в страницы, просматриваемые другими пользователями. Эта атака может привести к различным последствиям, включая кражу куки-файлов, перехват сессий, отображение фальшивого содержимого и так далее.

XSS атаки классифицируются на несколько типов:

### 1. Stored XSS (Постоянный)

Этот вид XSS атаки заключается в сохранении вредоносного кода на сервере. Например, если у вас на сайте есть форум или комментарии, и они не фильтруются как следует, злоумышленник может оставить там вредоносный JavaScript-код. Когда другие пользователи будут просматривать эти страницы, вредоносный код будет исполняться.
```
Привет, это мой комментарий! <script>alert('Вы атакованы');</script>
```

### 2. Reflected XSS (Отраженный)
В этом случае вредоносный скрипт внедряется через URL. Злоумышленник отправляет URL с вредоносным кодом жертве, и когда та открывает его, код исполняется.
```
https://example.com/search?query=<script>alert('Вы атакованы');</script>
```

### 3. DOM-based XSS (Основанный на DOM)

Здесь атака происходит в самом DOM, без участия сервера. Вредоносный код внедряется через манипуляции с DOM, например, через `innerHTML`, `document.write` и другие JavaScript методы.
```
document.getElementById('content').innerHTML = location.hash.slice(1);
```

#### Предотвращение XSS:
- Использовать экранирование символов: Всегда преобразуйте специальные символы, такие как `<`, `>`, `&` в HTML-сущности.
- Использовать Content Security Policy (CSP): Это дополнительный слой защиты, который помогает предотвратить XSS.
- Валидация и санитизация данных: Всегда проверяйте и фильтруйте данные, которые могут быть использованы для внедрения кода.
***
# Как работает JS под капотом
Как вы, возможно, слышали ранее, JavaScript — это интерпретируемый высокоуровневый язык программирования. Это означает, что перед исполнением исходный код не компилируется в двоичный код.

### JavaScript Engine
Как же компьютер может понять, что ему делать с простым тестовым скриптом? В этом и заключается работа движка JavaScript. Движок — это просто компьютерная программа, исполняющая код JavaScript. Движки JavaScript встроены во все современные браузеры. Когда файл скрипта загружается в браузер, движок исполняет каждую строку файла сверху вниз (чтобы упростить объяснение, мы не будем рассматривать поднятие (hoisting) в JS). Движок строка за строкой парсит код, преобразует его в машинный код, а затем исполняет.
У каждого браузера есть собственный движок JavaScript, но самым известным является Google V8. Движок V8 лежит в основе Google Chrome, а также Node.js.

Движок состоит из двух основных компонентов:  
- Куча памяти (memory heap) — здесь происходит распределение памяти.
- Стек вызовов (call stack) — здесь находятся стековые кадры в процессе исполнения кода.

Любой движок JavaScript всегда содержит стек вызовов и кучу. Именно в стеке вызовов исполняется наш код. А куча — это пул неструктурированной памяти, хранящий все объекты, необходимые приложению.

## Runtime
  
Пока мы говорили только о движке JavaScript, но он не работает в изоляции. Он выполняется в среде под названием JavaScript Runtime Environment наряду со множеством других компонентов. JRE отвечает за обеспечение асинхронности JavaScript. Именно благодаря ей JavaScript способен добавлять события и выполнять HTTP-запросы асинхронно. JRE похожа на контейнер, состоящий из следующих компонентов:  

- JS Engine;
- Web API;
- Очередь обратных вызовов или очередь сообщений;
- Таблица событий;
- Цикл событий.